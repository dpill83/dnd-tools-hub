<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D 5e Combat Turn Helper</title>
    <link rel="stylesheet" href="../global.css">
    <link rel="stylesheet" href="combat-turn-helper.css">
    <!-- PDF.js for PDF text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        (function() {
            function configureWorker() {
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                } else {
                    // Retry if library not loaded yet
                    setTimeout(configureWorker, 100);
                }
            }
            configureWorker();
        })();
    </script>
    <script src="character-sheet-importer.js"></script>
    <script src="theme.js"></script>
</head>
<body>
    <header class="combat-tool-header">
        <a href="../index.html" class="theme-toggle" aria-label="Go to home"><span class="theme-icon">&#127968;</span></a>
        <span class="combat-tool-title">Combat Turn Helper</span>
        <button type="button" id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode"><span class="theme-icon">&#127769;</span></button>
    </header>
    <div class="container">
        <!-- Home Screen -->
        <div class="screen active" id="screen-home">
            <!-- Help Section (collapsible, shown on first visit) -->
            <div class="collapsible-section" id="help-section" style="margin-bottom: 1rem;">
                <div class="collapsible-header" onclick="toggleCollapsible('help-section')">
                    <span class="collapsible-header-text">‚ùì What do these mean?</span>
                    <span class="collapsible-icon">‚ñ∂</span>
                </div>
                <div class="collapsible-content">
                    <div class="help-content-box">
                        <p><strong>üèÉ Movement:</strong> Move up to your speed. You can split this before and after your action.</p>
                        <p><strong>‚öîÔ∏è Action:</strong> Most common actions are Attack or Cast a Spell. You can also Dash, Dodge, Help, and more.</p>
                        <p><strong>‚ú® Bonus Action:</strong> Only if you have a feature that grants one (like Rage, Cunning Action, or a spell).</p>
                        <p><strong>ü§è Interaction:</strong> One free object interaction per turn (draw weapon, open door, pick up item).</p>
                        <p><strong>‚ö° Reaction:</strong> Tracked on the "NOT YOUR TURN" screen. You get one per round.</p>
                    </div>
                </div>
            </div>

            <!-- Dash Note -->
            <div class="dash-note" id="dash-note">
                üí® Extra movement granted this turn (Dash active)
            </div>

            <!-- Turn Log -->
            <div class="turn-log" id="turn-log" style="display: none;">
                <div class="turn-log-header">
                    <span>üìã Turn Log</span>
                    <span class="turn-log-clear" onclick="clearTurnLog()">Clear</span>
                </div>
                <div id="turn-log-entries"></div>
            </div>

            <div id="home-available" class="button-grid"></div>
            <div id="home-used" class="button-grid used-grid"></div>
            <div id="home-minor-buttons" class="minor-buttons"></div>
        </div>

        <!-- NOT YOUR TURN Screen -->
        <div class="screen" id="screen-not-your-turn">
            <h1 class="headline not-your-turn">‚è∏Ô∏è NOT YOUR TURN</h1>
            
            <div class="button-grid start-turn-grid">
                <button class="btn btn-primary" onclick="handleStartTurn()">‚ñ∂Ô∏è START TURN</button>
            </div>
            
            <!-- Reaction Widget -->
            <div class="reaction-widget-large" id="reaction-widget-container">
                <div class="reaction-header">
                    <div class="reaction-label-large">‚ö° Reaction</div>
                    <div class="tracker-status reaction-status-large" onclick="toggleReaction()" title="Click to toggle when you use your reaction" id="reaction-widget-status-2">Available</div>
                </div>
                <p class="reaction-hint">Click the status above to mark when you use your reaction</p>
            </div>

            <!-- Common Reactions Reference -->
            <div class="reactions-reference" id="reactions-reference-container">
                <h3 class="section-title">Common Reactions:</h3>
                <div class="reactions-list" id="reactions-list">
                    <!-- Non-spell reactions (always shown) -->
                    <div class="reaction-item" onclick="toggleReactionDetail(this)">
                        <div class="reaction-item-header">
                            <div class="reaction-item-title">
                                <span>‚öîÔ∏è</span>
                                <strong>Opportunity Attack</strong>
                                <span class="reaction-item-subtitle">- When enemy leaves your reach</span>
                            </div>
                            <span class="reaction-item-expand-icon">‚ñ∂</span>
                        </div>
                        <div class="reaction-item-details">
                            <p><strong>You can make an opportunity attack when a hostile creature that you can see moves out of your reach.</strong></p>
                            <p>To make the opportunity attack, you use your reaction to make one melee attack against the provoking creature. The attack occurs right before the creature leaves your reach.</p>
                            <p>You can avoid provoking an opportunity attack by taking the Disengage action. You also don't provoke an opportunity attack when you teleport or when someone or something moves you without using your movement, action, or reaction.</p>
                            <div class="reaction-page-numbers">
                                PHB 2014: p.195 | PHB 2024: [PAGE_PLACEHOLDER]
                            </div>
                        </div>
                    </div>
                    <div class="reaction-item" onclick="toggleReactionDetail(this)">
                        <div class="reaction-item-header">
                            <div class="reaction-item-title">
                                <span>‚è≥</span>
                                <strong>Ready Action</strong>
                                <span class="reaction-item-subtitle">- Use your readied action (if reserved)</span>
                            </div>
                            <span class="reaction-item-expand-icon">‚ñ∂</span>
                        </div>
                        <div class="reaction-item-details">
                            <p><strong>Sometimes you want to get the jump on a foe or wait for a particular circumstance before you act. To do so, you can take the Ready action on your turn, which lets you act using your reaction before the start of your next turn.</strong></p>
                            <p>First, you decide what perceivable circumstance will trigger your reaction. Then, you choose the action you will take in response to that trigger, or you choose to move up to your speed in response to it. Examples include "If the cultist steps on the trapdoor, I'll pull the lever that opens it," and "If the goblin steps next to me, I move away."</p>
                            <p><strong>When the trigger occurs, you can either take your reaction right after the trigger finishes or ignore the trigger. Remember that you can take only one reaction per round.</strong></p>
                            <p>When you ready a spell, you cast it as normal but hold its energy, which you release with your reaction when the trigger occurs. To be readied, a spell must have a casting time of 1 action, and holding onto the spell's magic requires concentration. If your concentration is broken, the spell dissipates without taking effect.</p>
                            <div class="reaction-page-numbers">
                                PHB 2014: p.193 | PHB 2024: [PAGE_PLACEHOLDER]
                            </div>
                        </div>
                    </div>
                    <!-- Spell reactions will be dynamically added here -->
                    <div id="spell-reactions-container"></div>
                </div>
            </div>

            <p class="hint-text">
                You can use your reaction during other creatures' turns.
            </p>
        </div>

        <!-- INTERACT Screen -->
        <div class="screen" id="screen-interact">
            <h1 class="headline">ü§è Simple Interaction</h1>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="handleInteract('draw-stow')">üó°Ô∏è Draw/Stow Weapon</button>
                <button class="btn btn-primary" onclick="handleInteract('door')">üö™ Open/Close Door</button>
                <button class="btn btn-primary" onclick="handleInteract('pickup-drop')">üì¶ Pick Up / Drop Item</button>
                <button class="btn btn-primary" onclick="handleInteract('move-object')">ü™ë Move Small Object</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- ACTION Screen -->
        <div class="screen" id="screen-action">
            <h1 class="headline">‚öîÔ∏è Choose Action</h1>
            
            <!-- Decision Helper Box -->
            <div class="decision-helper-box" id="decision-helper-box" style="display:none;">
                <div class="decision-helper-prompt" id="decision-helper-prompt" onclick="rotateHelperPrompt()"></div>
                <div class="decision-helper-chips" id="decision-helper-chips" style="display:none;"></div>
            </div>
            
            <!-- Primary actions (Attack and Cast Spell) -->
            <div class="button-grid">
                <button class="btn btn-accent" onclick="showAttackTree()">‚öîÔ∏è Attack</button>
                <button class="btn btn-primary" onclick="showSpellSelection('action')">‚ú® Cast a Spell</button>
            </div>
            
            <!-- Spellcaster Reminders -->
            <div id="spellcaster-reminders" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background-color: rgba(212, 175, 55, 0.1); border-left: 3px solid var(--accent-color); border-radius: 4px; font-size: 0.875rem;">
                <p style="margin: 0; font-weight: 600; margin-bottom: 0.5rem;">‚ú® Spellcaster Reminders:</p>
                <p style="margin: 0.25rem 0;">üí≠ Concentration?</p>
                <p style="margin: 0.25rem 0;">üìö Spell slots?</p>
            </div>
            
            <!-- Other actions in collapsible section -->
            <div class="collapsible-section" id="other-actions-section">
                <div class="collapsible-header" onclick="toggleCollapsible('other-actions-section')">
                    <span class="collapsible-header-text">üìã Other Actions</span>
                    <span class="collapsible-icon">‚ñ∂</span>
                </div>
                <div class="collapsible-content">
                    <div class="action-grid">
                        <button class="btn btn-primary" onclick="handleDash()">üí® Dash</button>
                        <button class="btn btn-primary" onclick="showActionDetail('search')">üîç Search</button>
                        <button class="btn btn-primary" onclick="showActionDetail('ready')">‚è≥ Ready</button>
                        <button class="btn btn-primary" onclick="showActionDetail('help')">ü§ù Help</button>
                        <button class="btn btn-primary" onclick="showActionDetail('dodge')">üõ°Ô∏è Dodge</button>
                        <button class="btn btn-primary" onclick="showActionDetail('disengage')">üèÉ‚Äç‚ôÇÔ∏è Disengage</button>
                        <button class="btn btn-primary" onclick="showActionDetail('hide')">ü•∑ Hide</button>
                        <button class="btn btn-primary" onclick="showActionDetail('use-object')">üîß Use Object</button>
                        <button class="btn btn-primary" onclick="showActionDetail('shove')">üí™ Shove</button>
                        <button class="btn btn-primary" onclick="showActionDetail('grapple')">ü§º Grapple</button>
                    </div>
                </div>
            </div>
            
            <!-- Interaction (Free) -->
            <div class="button-grid" id="interaction-button-container">
                <button class="btn btn-secondary" onclick="handleInteractClick()">ü§è INTERACT (Free)</button>
            </div>
            
            <!-- Back button -->
            <div class="button-grid">
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- Attack Decision Tree -->
        <div class="screen" id="screen-attack">
            <h1 class="headline">‚öîÔ∏è Attack</h1>
            <div class="attack-tree" id="attack-step-1">
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="attackStep(2, 'weapon')">üó°Ô∏è Weapon Attack</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'spell')">‚ú® Spell Attack</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save')">üé≤ Target Makes a Save</button>
                    <button class="btn btn-secondary" onclick="showScreen('screen-action')">‚Üê Back</button>
                </div>
            </div>

            <!-- Weapon Attack Flow - Simplified: Direct to roll result -->
            <div class="attack-tree" id="attack-weapon">
                <div class="modal-body">
                    <p><strong>Roll d20 + modifier (STR for melee, DEX for ranged/finesse)</strong></p>
                    <div class="help-text">
                        <div>Advantage/Disadvantage?</div>
                        <div>Nat 20 = crit (double dice)</div>
                        <div>Remember Bless/Bane/Guidance/Advantage.</div>
                    </div>
                    <div id="extra-attack-reminder" style="display: none; margin-top: 1rem; padding: 0.75rem; background-color: rgba(0, 0, 0, 0.05); border-radius: 4px;">
                        <p style="margin-bottom: 0.5rem; font-weight: 600;">Extra Attack Reminder:</p>
                        <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <input type="checkbox" style="width: 18px; height: 18px;" />
                            <span>Attack 1</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" style="width: 18px; height: 18px;" />
                            <span>Attack 2</span>
                        </label>
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-success" onclick="attackStep(3, 'hit')">‚úÖ Hit</button>
                    <button class="btn btn-danger" onclick="attackStep(3, 'miss')">‚ùå Miss</button>
                    <button class="btn btn-secondary" onclick="attackStep(1)">‚Üê Back</button>
                </div>
            </div>

            <!-- Spell Attack Flow -->
            <div class="attack-tree" id="attack-spell">
                <div class="modal-body">
                    <p><strong>Roll d20 + spellcasting ability modifier + proficiency bonus</strong></p>
                    <div class="help-text">
                        <div>Advantage/Disadvantage?</div>
                        <div>Cover may add +2/+5 AC</div>
                        <div>Nat 20 = crit (double dice)</div>
                        <div>Remember Bless/Bane/Guidance/Advantage.</div>
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-success" onclick="attackStep(3, 'hit')">‚úÖ Hit</button>
                    <button class="btn btn-danger" onclick="attackStep(3, 'miss')">‚ùå Miss</button>
                    <button class="btn btn-secondary" onclick="attackStep(1)">‚Üê Back</button>
                </div>
            </div>

            <!-- Save Flow -->
            <div class="attack-tree" id="attack-save-type">
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-str')">STR</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-dex')">DEX</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-con')">CON</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-int')">INT</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-wis')">WIS</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-cha')">CHA</button>
                    <button class="btn btn-secondary" onclick="attackStep(1)">‚Üê Back</button>
                </div>
            </div>

            <div class="attack-tree" id="attack-save-result">
                <div class="modal-body">
                    <p><strong>DM rolls d20 + target's <span id="save-type-name"></span> modifier vs your spell save DC</strong></p>
                    <p>Spell save DC = 8 + proficiency bonus + spellcasting ability modifier</p>
                </div>
                <div class="button-grid">
                    <button class="btn btn-success" onclick="attackStep(3, 'save-succeeds')">‚úÖ Save Succeeds</button>
                    <button class="btn btn-danger" onclick="attackStep(3, 'save-fails')">‚ùå Save Fails</button>
                    <button class="btn btn-secondary" onclick="attackStep(2, 'save')">‚Üê Back</button>
                </div>
            </div>

            <!-- Hit/Miss Results - Combined into one screen -->
            <div class="attack-tree" id="attack-result">
                <div class="modal-body" id="attack-result-content">
                    <!-- Content will be populated by JavaScript -->
                </div>
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="confirmAttackAction()">‚úÖ Confirm Action</button>
                    <button class="btn btn-secondary" onclick="goBackFromAttackResult()">‚Üê Back</button>
                </div>
            </div>
        </div>

        <!-- BONUS ACTION Screen -->
        <div class="screen" id="screen-bonus-action">
            <h1 class="headline">‚ú® Bonus Action</h1>
            <div class="button-grid" id="bonus-action-options"></div>
            <div class="button-grid tight-top">
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- Spell Selection Screen (for ACTION) -->
        <div class="screen" id="screen-spell-selection-action">
            <h1 class="headline">‚ú® Cast a Spell (Action)</h1>
            <div id="spell-selection-content-action" class="spell-selection-content">
                <!-- Content populated by JavaScript -->
            </div>
            <div class="button-grid">
                <button class="btn btn-secondary" onclick="showScreen('screen-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- Spell Selection Screen (for BONUS ACTION) -->
        <div class="screen" id="screen-spell-selection-bonus">
            <h1 class="headline">‚ú® Cast a Spell (Bonus Action)</h1>
            <div id="spell-selection-content-bonus" class="spell-selection-content">
                <!-- Content populated by JavaScript -->
            </div>
            <div class="button-grid">
                <button class="btn btn-secondary" onclick="showScreen('screen-bonus-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- END TURN Screen -->
        <div class="screen" id="screen-end-turn">
            <div class="end-turn-container">
                <h1 class="headline">‚úÖ End Turn</h1>
                <ul class="checklist-screen">
                    <li>
                        <span>üèÉ Movement</span>
                        <span class="status" id="checklist-movement">Unused</span>
                    </li>
                    <li>
                        <span>‚öîÔ∏è Action</span>
                        <span class="status" id="checklist-action">Unused</span>
                    </li>
                    <li>
                        <span>‚ú® Bonus Action</span>
                        <span class="status" id="checklist-bonus-action">Unused</span>
                    </li>
                    <li id="checklist-interaction-item">
                        <span>ü§è Interaction</span>
                        <span class="status" id="checklist-interaction">Unused</span>
                    </li>
                </ul>
                <!-- Quick actions for unused resources -->
                <div id="end-turn-quick-actions" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background-color: rgba(255, 193, 7, 0.1); border-left: 3px solid var(--warning); border-radius: 4px;">
                    <p style="margin: 0 0 0.5rem 0; font-weight: 600; font-size: 0.875rem;">You still have unused resources:</p>
                    <div id="end-turn-quick-buttons" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-danger" onclick="confirmEndTurn()">‚úÖ Confirm End Turn</button>
                    <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
                </div>
            </div>
        </div>

        <!-- MOVE Detail Screen -->
        <div class="screen" id="screen-move-detail">
            <h1 class="headline">üèÉ Move</h1>
            <div class="detail-content">
                <!-- Speed Display (D&D Character Sheet Style) -->
                <div class="speed-display" id="move-speed-display" style="display: none;">
                    <div class="speed-display-value">
                        <div>
                            <span class="speed-number" id="move-speed-number">30</span>
                            <span class="speed-unit">ft.</span>
                        </div>
                        <div class="speed-type" id="move-speed-type">Walking</div>
                    </div>
                    <div class="speed-display-label">SPEED</div>
                </div>
                
                <p><strong>Move up to your speed, before or after your action.</strong></p>
                <p id="move-description-text">On your turn, you can move a distance up to your speed. You can use some of your movement before and after your action. For example, if you have a speed of 30 feet, you can move 10 feet, take your action, and then move 20 feet more.</p>
            </div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmMove()">‚úÖ Confirm Move</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- DASH Detail Screen -->
        <div class="screen" id="screen-dash-detail">
            <h1 class="headline">üí® Dash</h1>
            <div class="detail-content">
                <p><strong>Dash: move up to your speed again (uses Action)</strong></p>
                <p>When you take the Dash action, you gain extra movement for the current turn. The increase equals your speed, after applying any modifiers. With a speed of 30 feet, for example, you can move up to 60 feet on your turn if you dash.</p>
                <p>Any increase or decrease to your speed changes this additional movement by the same amount. If your speed of 30 feet is reduced to 15 feet, for instance, you can move up to 30 feet this turn if you dash.</p>
            </div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmDash()">‚úÖ Confirm Dash</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- INTERACT Detail Screens -->
        <div class="screen" id="screen-interact-detail">
            <h1 class="headline" id="interact-detail-title">ü§è Simple Interaction</h1>
            <div class="detail-content" id="interact-detail-content"></div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmInteract()">‚úÖ Confirm Interaction</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-interact')">‚Üê Back</button>
            </div>
        </div>

        <!-- ACTION Detail Screens -->
        <div class="screen" id="screen-action-detail">
            <h1 class="headline" id="action-detail-title">‚öîÔ∏è Action</h1>
            <div class="detail-content" id="action-detail-content"></div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmActionDetail()">‚úÖ Confirm Action</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- BONUS ACTION Detail Screens -->
        <div class="screen" id="screen-bonus-action-detail">
            <h1 class="headline" id="bonus-action-detail-title">‚ú® Bonus Action</h1>
            <div class="detail-content" id="bonus-action-detail-content"></div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmBonusAction()">‚úÖ Confirm Bonus Action</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-bonus-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- SETTINGS Screen -->
        <div class="screen" id="screen-settings">
            <h1 class="headline">‚öôÔ∏è Settings</h1>
            
            <!-- Character Library -->
            <div class="character-setup-compact" style="margin-bottom: 1rem;">
                <div class="setup-row">
                    <label for="character-library-select">üìö Active Character</label>
                    <select id="character-library-select" onchange="switchCharacter(this.value)">
                        <option value="">(No Character)</option>
                    </select>
                </div>
                <div class="button-grid" style="margin-top: 0.75rem;">
                    <button class="btn btn-secondary btn-small" onclick="createNewCharacter()">‚ûï New</button>
                    <button class="btn btn-secondary btn-small" onclick="document.getElementById('import-pdf-file').click()">üìÑ Import PDF</button>
                    <button class="btn btn-secondary btn-small" onclick="document.getElementById('import-json-file').click()">üì• Import JSON</button>
                    <button class="btn btn-secondary btn-small" onclick="exportCharacterJSON()">üíæ Export JSON</button>
                    <button class="btn btn-secondary btn-small" onclick="duplicateCurrentCharacter()">üìã Duplicate</button>
                    <button class="btn btn-secondary btn-small" onclick="deleteCurrentCharacter()">üóëÔ∏è Delete</button>
                </div>
                <input type="file" id="import-pdf-file" accept=".pdf" style="display:none;" onchange="handlePdfImport(event)">
                <input type="file" id="import-json-file" accept=".json" style="display:none;" onchange="handleJsonImport(event)">
            </div>
            
            <!-- Character Setup -->
            <div class="character-setup-compact">
                <div class="setup-row">
                    <label for="class-select">‚öôÔ∏è Class</label>
                    <select id="class-select">
                        <option value="">(Select)</option>
                        <option value="barbarian">Barbarian</option>
                        <option value="bard">Bard</option>
                        <option value="cleric">Cleric</option>
                        <option value="fighter">Fighter</option>
                        <option value="monk">Monk</option>
                        <option value="paladin">Paladin</option>
                        <option value="ranger">Ranger</option>
                        <option value="rogue">Rogue</option>
                        <option value="sorcerer">Sorcerer</option>
                        <option value="warlock">Warlock</option>
                        <option value="wizard">Wizard</option>
                        <option value="other">Other / None</option>
                    </select>
                </div>
                <div class="setup-toggles">
                    <label title="Enable Bonus Action button on Home screen">
                        <input type="checkbox" id="toggle-bonus-action-enabled" />
                        ‚ú® Bonus Action
                    </label>
                    <label title="Show Healing Word option">
                        <input type="checkbox" id="toggle-healing-word" />
                        üíö Healing Word
                    </label>
                    <label title="Show offhand attack option">
                        <input type="checkbox" id="toggle-offhand-attack" />
                        üó°Ô∏è Offhand
                    </label>
                </div>
            </div>


            <!-- Must-Have Settings -->
            <div class="character-setup-compact" style="margin-top: 1rem;">
                <h3 class="section-title" style="margin-bottom: 0.5rem;">Must-Have</h3>
                <div class="setup-toggles">
                    <label title="Track reaction on NOT YOUR TURN screen">
                        <input type="checkbox" id="toggle-track-reaction" />
                        ‚ö° Track Reaction
                    </label>
                    <label title="Track free interaction (draw weapon, open door, etc.)">
                        <input type="checkbox" id="toggle-track-interaction" />
                        ü§è Track Interaction
                    </label>
                </div>
            </div>

            <!-- Useful but Optional Settings (Collapsible) -->
            <div class="collapsible-section" id="useful-settings-section" style="margin-top: 1rem;">
                <div class="collapsible-header" onclick="toggleCollapsible('useful-settings-section')">
                    <span class="collapsible-header-text">‚öôÔ∏è Advanced Settings</span>
                    <span class="collapsible-icon">‚ñ∂</span>
                </div>
                <div class="collapsible-content">
                    <div class="character-setup-compact">
                        <div class="setup-toggles">
                            <label title="Show Extra Attack reminder in attack flow">
                                <input type="checkbox" id="toggle-extra-attack" />
                                ‚öîÔ∏è Extra Attack Reminder
                            </label>
                            <label title="Show spellcaster reminders (concentration, spell slots)">
                                <input type="checkbox" id="toggle-spellcaster-mode" />
                                ‚ú® Spellcaster Mode
                            </label>
                            <label title="Show confirmation dialogs before spending resources">
                                <input type="checkbox" id="toggle-confirm-spends" />
                                ‚úì Confirm Spends
                            </label>
                            <label title="Show decision helper prompts on ACTION screen">
                                <input type="checkbox" id="toggle-decision-helper" />
                                üí° Decision Helper
                            </label>
                        </div>
                        <div class="setup-row" style="margin-top: 0.75rem;">
                            <label for="helper-preset-select">Helper Preset</label>
                            <select id="helper-preset-select">
                                <option value="none">None</option>
                                <option value="cleric">Cleric</option>
                                <option value="barbarian">Barbarian</option>
                                <option value="rogue">Rogue</option>
                                <option value="wizard">Wizard</option>
                            </select>
                        </div>
                        <div class="setup-toggles" style="margin-top: 0.75rem;">
                            <label title="Make buttons larger for phone-at-the-table use">
                                <input type="checkbox" id="toggle-big-button-mode" />
                                üì± Big Button Mode
                            </label>
                            <label title="Automatically reset resources when starting turn">
                                <input type="checkbox" id="toggle-auto-reset" />
                                üîÑ Auto-Reset on Start Turn
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="button-grid">
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- Toast Notification -->
        <div class="toast" id="toast"></div>

        <!-- Reset Dialog -->
        <div class="reset-dialog" id="reset-dialog">
            <div class="reset-dialog-content">
                <div class="reset-dialog-message">
                    Reset all turn state? This will clear your current progress.
                </div>
                <div class="reset-dialog-actions">
                    <button class="btn btn-secondary btn-small" onclick="closeResetDialog()">Cancel</button>
                    <button class="btn btn-danger btn-small" onclick="confirmReset()">Reset All</button>
                </div>
                <div class="reset-dialog-rest">
                    <span class="reset-dialog-rest-label">Rest:</span>
                    <button class="btn btn-secondary btn-small" onclick="handleLongRest()">Long Rest</button>
                    <button class="btn btn-secondary btn-small" onclick="handleShortRest()">Short Rest</button>
                </div>
            </div>
        </div>

        <!-- End Turn Safety Net Dialog -->
        <div class="end-turn-dialog" id="end-turn-dialog">
            <div class="end-turn-dialog-content">
                <div class="end-turn-dialog-message" id="end-turn-dialog-message">
                    <!-- Message will be populated by JavaScript -->
                </div>
                <div class="end-turn-dialog-quick-actions" id="end-turn-dialog-quick-actions">
                    <div class="end-turn-dialog-quick-buttons" id="end-turn-dialog-quick-buttons">
                        <!-- Quick action buttons will be populated by JavaScript -->
                    </div>
                </div>
                <div class="end-turn-dialog-actions">
                    <button class="btn btn-secondary btn-small" onclick="closeEndTurnDialog()">Go Back</button>
                    <button class="btn btn-danger btn-small" onclick="confirmEndTurnAnyway()">End Turn</button>
                </div>
            </div>
        </div>

        <!-- Import Character Confirmation Dialog -->
        <div class="import-confirm-dialog" id="import-confirm-dialog">
            <div class="import-confirm-dialog-content">
                <div class="import-confirm-dialog-header">
                    <h2>Confirm Character Import</h2>
                </div>
                <div class="import-confirm-dialog-body" id="import-confirm-dialog-body">
                    <!-- Content will be populated by JavaScript -->
                </div>
                <div class="import-confirm-dialog-actions">
                    <button class="btn btn-secondary btn-small" onclick="closeImportConfirmDialog()">Cancel</button>
                    <button class="btn btn-primary btn-small" onclick="confirmCharacterImport()">Confirm</button>
                </div>
            </div>
        </div>

        <!-- Spell Slot Spending Dialog -->
        <div class="spell-slot-dialog" id="spell-slot-dialog">
            <div class="spell-slot-dialog-content">
                <div class="spell-slot-dialog-message" id="spell-slot-dialog-message">
                    <!-- Message will be populated by JavaScript -->
                </div>
                <div class="spell-slot-dialog-actions">
                    <button class="btn btn-secondary btn-small" onclick="cancelSpellSlotSpend()">No</button>
                    <button class="btn btn-primary btn-small" onclick="confirmSpellSlotSpend()">Yes</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State Management
        let state = {
            movement: 'available',
            action: 'available',
            bonusAction: 'available',
            interaction: 'available',
            reaction: 'available',
            dashActive: false,
            actionUsedBy: null,
            currentAttackStep: 1,
            currentSaveType: null,
            pendingAction: null,
            lastAttackType: null,  // Track last attack type for back button
            spellSlotsUsed: {},  // Track used spell slots: {1: 2, 2: 0, ...}
            turnLog: []  // Track spell casts and actions: [{timestamp, action, spell?, level?}]
        };

        // Preferences (class + available options)
        const PREFS_KEY = 'combatTurnPrefs';
        let prefs = {
            classKey: '',
            canHealingWord: false,
            canOffhandAttack: false,
            bonusActionEnabled: false,
            // Must-have settings
            trackReaction: true,
            trackInteraction: true,
            // Useful but optional settings
            extraAttackReminder: false,
            spellcasterMode: false,
            confirmSpends: false,
            decisionHelperEnabled: false,
            helperPreset: 'none',
            // Quality-of-life settings
            bigButtonMode: false,
            autoResetOnStartTurn: false
        };

        // Load state from localStorage
        function loadState() {
            const saved = localStorage.getItem('combatTurnState');
            if (saved) {
                state = { ...state, ...JSON.parse(saved) };
                // Backward compatibility: ensure actionUsedBy defaults to null
                if (state.actionUsedBy === undefined) {
                    state.actionUsedBy = null;
                }
                // Backward compatibility: ensure spellSlotsUsed exists
                if (state.spellSlotsUsed === undefined) {
                    state.spellSlotsUsed = {};
                }
                // Backward compatibility: ensure turnLog exists
                if (state.turnLog === undefined) {
                    state.turnLog = [];
                }
            }
            updateUI();
        }

        function loadPrefs() {
            const saved = localStorage.getItem(PREFS_KEY);
            if (saved) {
                prefs = { ...prefs, ...JSON.parse(saved) };
            }
            // Backward compatibility: ensure defaults for all settings
            if (prefs.bonusActionEnabled === undefined) {
                prefs.bonusActionEnabled = false;
            }
            if (prefs.trackReaction === undefined) {
                prefs.trackReaction = true;
            }
            if (prefs.trackInteraction === undefined) {
                prefs.trackInteraction = true;
            }
            if (prefs.extraAttackReminder === undefined) {
                prefs.extraAttackReminder = false;
            }
            if (prefs.spellcasterMode === undefined) {
                prefs.spellcasterMode = false;
            }
            if (prefs.confirmSpends === undefined) {
                prefs.confirmSpends = false;
            }
            if (prefs.bigButtonMode === undefined) {
                prefs.bigButtonMode = false;
            }
            if (prefs.autoResetOnStartTurn === undefined) {
                prefs.autoResetOnStartTurn = false;
            }
            if (prefs.decisionHelperEnabled === undefined) {
                prefs.decisionHelperEnabled = false;
            }
            if (prefs.helperPreset === undefined) {
                prefs.helperPreset = 'none';
            }

            const classSelect = document.getElementById('class-select');
            const toggleBonusAction = document.getElementById('toggle-bonus-action-enabled');
            const toggleHealing = document.getElementById('toggle-healing-word');
            const toggleOffhand = document.getElementById('toggle-offhand-attack');
            const toggleTrackReaction = document.getElementById('toggle-track-reaction');
            const toggleTrackInteraction = document.getElementById('toggle-track-interaction');
            const toggleExtraAttack = document.getElementById('toggle-extra-attack');
            const toggleSpellcaster = document.getElementById('toggle-spellcaster-mode');
            const toggleConfirmSpends = document.getElementById('toggle-confirm-spends');
            const toggleBigButton = document.getElementById('toggle-big-button-mode');
            const toggleAutoReset = document.getElementById('toggle-auto-reset');
            const toggleDecisionHelper = document.getElementById('toggle-decision-helper');
            const helperPresetSelect = document.getElementById('helper-preset-select');

            if (classSelect) classSelect.value = prefs.classKey || '';
            if (toggleBonusAction) toggleBonusAction.checked = !!prefs.bonusActionEnabled;
            if (toggleHealing) toggleHealing.checked = !!prefs.canHealingWord;
            if (toggleOffhand) toggleOffhand.checked = !!prefs.canOffhandAttack;
            if (toggleTrackReaction) toggleTrackReaction.checked = !!prefs.trackReaction;
            if (toggleTrackInteraction) toggleTrackInteraction.checked = !!prefs.trackInteraction;
            if (toggleExtraAttack) toggleExtraAttack.checked = !!prefs.extraAttackReminder;
            if (toggleSpellcaster) toggleSpellcaster.checked = !!prefs.spellcasterMode;
            if (toggleConfirmSpends) toggleConfirmSpends.checked = !!prefs.confirmSpends;
            if (toggleBigButton) toggleBigButton.checked = !!prefs.bigButtonMode;
            if (toggleAutoReset) toggleAutoReset.checked = !!prefs.autoResetOnStartTurn;
            if (toggleDecisionHelper) toggleDecisionHelper.checked = !!prefs.decisionHelperEnabled;
            if (helperPresetSelect) helperPresetSelect.value = prefs.helperPreset || 'none';

            // Apply big button mode CSS class if enabled
            if (prefs.bigButtonMode) {
                document.body.classList.add('big-button-mode');
            } else {
                document.body.classList.remove('big-button-mode');
            }
        }

        function savePrefs() {
            localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
        }

        function getClassFeatureBonusAction() {
            switch (prefs.classKey) {
                case 'barbarian':
                    return {
                        title: 'üò§ Rage (Barbarian)',
                        content: '<p><strong>Enter a rage as a bonus action.</strong></p><ul><li>Advantage on STR checks/saves</li><li>Bonus damage (varies by level)</li><li>Resistance to bludgeoning/piercing/slashing (while raging)</li></ul><p>Ends early if you end your turn without attacking or taking damage (PHB rules).</p>'
                    };
                case 'bard':
                    return {
                        title: 'üé∂ Bardic Inspiration (Bard)',
                        content: '<p><strong>Give an inspiration die to a creature within 60 ft who can hear you.</strong></p><ul><li>They can add it to an ability check / attack roll / saving throw (timing varies by feature)</li><li>Die size scales with level</li></ul>'
                    };
                case 'fighter':
                    return {
                        title: 'üí™ Second Wind (Fighter)',
                        content: '<p><strong>Regain hit points as a bonus action.</strong></p><ul><li>Heal 1d10 + fighter level</li><li>Once per short/long rest</li></ul>'
                    };
                case 'monk':
                    return {
                        title: 'ü•ã Monk Bonus Action',
                        content: '<p><strong>Common monk bonus actions:</strong></p><ul><li><strong>Martial Arts:</strong> unarmed strike after Attack action</li><li><strong>Flurry of Blows:</strong> spend 1 ki for 2 strikes</li><li><strong>Step of the Wind:</strong> spend 1 ki to Dash/Disengage + jump</li><li><strong>Patient Defense:</strong> spend 1 ki to Dodge</li></ul>'
                    };
                case 'rogue':
                    return {
                        title: 'üó°Ô∏è Cunning Action (Rogue)',
                        content: '<p><strong>Take Dash, Disengage, or Hide as a bonus action.</strong></p><ul><li>Dash: extra movement</li><li>Disengage: avoid opportunity attacks</li><li>Hide: attempt to hide (DM rules)</li></ul>'
                    };
                default:
                    return null;
            }
        }

        function getBonusActionOptions() {
            const options = [];
            if (prefs.canHealingWord) options.push({ key: 'healing-word', label: 'üíö Healing Word' });
            const classFeature = getClassFeatureBonusAction();
            if (classFeature) options.push({ key: 'class-feature', label: classFeature.title });
            if (prefs.canOffhandAttack) options.push({ key: 'offhand-attack', label: 'üó°Ô∏è Offhand Attack' });
            return options;
        }

        function hasBonusActionOptions() {
            // Bonus Action must be enabled in settings AND have at least one option
            return prefs.bonusActionEnabled && getBonusActionOptions().length > 0;
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('combatTurnState', JSON.stringify(state));
        }

        // Update UI based on state
        function updateUI() {
            // Update reaction widget (on NOT YOUR TURN screen)
            updateReactionWidget();

            // Update home buttons
            updateHomeButtons();

            // Update turn log
            updateTurnLog();

            // Update dash note
            document.getElementById('dash-note').style.display = state.dashActive ? 'block' : 'none';

            // Show/hide interaction button in ACTION screen based on setting
            const interactionButtonContainer = document.getElementById('interaction-button-container');
            if (interactionButtonContainer) {
                interactionButtonContainer.style.display = prefs.trackInteraction ? 'block' : 'none';
            }

            // Show/hide spellcaster reminders based on setting
            const spellcasterReminders = document.getElementById('spellcaster-reminders');
            if (spellcasterReminders) {
                spellcasterReminders.style.display = prefs.spellcasterMode ? 'block' : 'none';
            }

            saveState();
        }

        // Count available resources (for End Turn safety net)
        function countAvailableResources() {
            let count = 0;
            const available = [];
            
            if (state.movement === 'available') {
                count++;
                available.push('Movement');
            }
            // Only count Bonus Action if enabled
            if (prefs.bonusActionEnabled && state.bonusAction === 'available' && hasBonusActionOptions()) {
                count++;
                available.push('Bonus Action');
            }
            // Only count Interaction if tracking is enabled
            if (prefs.trackInteraction && state.interaction === 'available') {
                count++;
                available.push('Interaction');
            }
            // Do NOT count Reaction - it's normal to have it available
            
            return { count, available };
        }

        function updateReactionWidget() {
            const status = state.reaction;
            const statusText = status.charAt(0).toUpperCase() + status.slice(1);
            const statusClass = 'tracker-status reaction-status-large ' + status;
            
            // Update reaction widget on NOT YOUR TURN screen
            const widget = document.getElementById('reaction-widget-status-2');
            if (widget) {
                widget.textContent = statusText;
                widget.className = statusClass;
            }
            
            // Show/hide reaction widget and reference based on setting
            const widgetContainer = document.getElementById('reaction-widget-container');
            const referenceContainer = document.getElementById('reactions-reference-container');
            if (widgetContainer) {
                widgetContainer.style.display = prefs.trackReaction ? 'block' : 'none';
            }
            if (referenceContainer) {
                referenceContainer.style.display = prefs.trackReaction ? 'block' : 'none';
            }
            
            // Update reaction spells list
            updateReactionSpells();
        }

        // Update home buttons - dynamically create and place in available/used sections
        function updateHomeButtons() {
            const availableContainer = document.getElementById('home-available');
            const usedContainer = document.getElementById('home-used');
            
            if (!availableContainer || !usedContainer) return;
            
            // Clear both containers
            availableContainer.innerHTML = '';
            usedContainer.innerHTML = '';
            
            // MOVE button (with speed if available)
            let moveLabel = 'üèÉ MOVE';
            let moveLabelUsed = '‚úÖ üèÉ MOVE';
            
            // Try to get speed from active character profile
            try {
                const profile = getActiveCharacterProfile();
                if (profile && profile.speed !== undefined && profile.speed !== null) {
                    moveLabel = `üèÉ MOVE (${profile.speed} ft)`;
                    moveLabelUsed = `‚úÖ üèÉ MOVE (${profile.speed} ft)`;
                }
            } catch (e) {
                // Ignore errors, use default label
            }
            
            if (state.movement === 'available') {
                const btn = createButton(moveLabel, 'btn-primary', () => handleMove());
                availableContainer.appendChild(btn);
            } else {
                const btn = createButton(moveLabelUsed, 'btn-primary used', () => handleUndoMove());
                usedContainer.appendChild(btn);
            }
            
            // ACTION button
            if (state.action === 'available') {
                const btn = createButton('‚öîÔ∏è ACTION', 'btn-primary', () => handleActionClick());
                availableContainer.appendChild(btn);
            } else if (state.action === 'used') {
                // If action was used for Dash, show DASH in used section
                if (state.actionUsedBy === 'dash') {
                    const btn = createButton('‚úÖ üí® DASH (Action)', 'btn-primary used', () => handleUndoDash());
                    usedContainer.appendChild(btn);
                } else {
                    const btn = createButton('‚úÖ ‚öîÔ∏è ACTION', 'btn-primary used', () => handleUndoAction());
                    usedContainer.appendChild(btn);
                }
            }
            
            // BONUS ACTION button (only if options available)
            if (state.bonusAction === 'available' && hasBonusActionOptions()) {
                const btn = createButton('‚ú® BONUS ACTION', 'btn-primary', () => handleBonusActionClick());
                availableContainer.appendChild(btn);
            } else if (state.bonusAction === 'used' && hasBonusActionOptions()) {
                const btn = createButton('‚úÖ ‚ú® BONUS ACTION', 'btn-primary used', () => handleUndoBonusAction());
                usedContainer.appendChild(btn);
            }
            
            // END TURN button (always in available) - dynamic label based on available resources
            const resources = countAvailableResources();
            const endTurnLabel = resources.count > 0 
                ? `‚úÖ END TURN (${resources.count} LEFT)` 
                : '‚úÖ END TURN';
            const endTurnBtn = createButton(endTurnLabel, 'btn-danger', () => handleEndTurn());
            availableContainer.appendChild(endTurnBtn);
            
            // Minor buttons container (Settings and Reset)
            const minorContainer = document.getElementById('home-minor-buttons');
            if (minorContainer) {
                minorContainer.innerHTML = '';
                const settingsBtn = createButton('‚öôÔ∏è Settings', 'btn-secondary', () => showScreen('screen-settings'));
                const resetBtn = createButton('üîÑ Reset All', 'btn-secondary', () => showResetDialog());
                minorContainer.appendChild(settingsBtn);
                minorContainer.appendChild(resetBtn);
            }
        }
        
        // Helper to create button element
        function createButton(text, className, onClick) {
            const btn = document.createElement('button');
            btn.className = `btn ${className}`;
            btn.textContent = text;
            btn.onclick = onClick;
            return btn;
        }


        // Screen Navigation
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            
            // Update decision helper when ACTION screen is shown
            if (screenId === 'screen-action') {
                updateDecisionHelper();
            }
            
            // Update speed display when MOVE screen is shown
            if (screenId === 'screen-move-detail') {
                updateMoveSpeedDisplay();
            }
            
            // Populate character library when SETTINGS screen is shown
            if (screenId === 'screen-settings') {
                populateCharacterLibrary();
            }
        }

        // Known bonus action spells (fallback if metadata not available)
        const BONUS_ACTION_SPELLS = [
            'Healing Word',
            'Sanctuary',
            'Shield of Faith',
            'Hunter\'s Mark',
            'Hex',
            'Misty Step',
            'Spiritual Weapon'
        ];

        // Check if a spell is a bonus action spell
        function isBonusActionSpell(spellName, profile) {
            // First check if we have casting time metadata in rawFields
            if (profile && profile.rawFields) {
                // Look for spellCastingTime fields
                const spellIndex = profile.spells ? profile.spells.indexOf(spellName) : -1;
                if (spellIndex >= 0) {
                    const castingTimeKey = `spellCastingTime${spellIndex}`;
                    const castingTime = profile.rawFields[castingTimeKey];
                    if (castingTime) {
                        const timeStr = String(castingTime).trim().toUpperCase();
                        // Check for "1BA" or "1 Bonus Action" patterns
                        if (timeStr.includes('1BA') || timeStr.includes('BONUS ACTION')) {
                            return true;
                        }
                    }
                }
            }
            
            // Fallback: check against known bonus action spells
            return BONUS_ACTION_SPELLS.some(baSpell => 
                spellName.toLowerCase().includes(baSpell.toLowerCase()) ||
                baSpell.toLowerCase().includes(spellName.toLowerCase())
            );
        }

        // Get bonus action spells from profile
        function getBonusActionSpells(profile) {
            if (!profile || !profile.spells) return [];
            return profile.spells.filter(spell => isBonusActionSpell(spell, profile));
        }

        // Get action spells from profile (all spells except bonus action spells)
        function getActionSpells(profile) {
            if (!profile || !profile.spells) return [];
            const bonusActionSpells = getBonusActionSpells(profile);
            return profile.spells.filter(spell => !bonusActionSpells.includes(spell));
        }

        // Show spell selection screen
        function showSpellSelection(actionType) {
            const profile = getActiveCharacterProfile();
            if (!profile) {
                showToast('No character loaded');
                return;
            }

            const screenId = actionType === 'bonus' ? 'screen-spell-selection-bonus' : 'screen-spell-selection-action';
            const contentId = actionType === 'bonus' ? 'spell-selection-content-bonus' : 'spell-selection-content-action';
            const content = document.getElementById(contentId);
            
            if (!content) return;

            let html = '';
            const hasCantrips = profile.cantrips && profile.cantrips.length > 0;
            const hasSpellSlots = profile.spellSlots && Object.keys(profile.spellSlots).length > 0;

            if (actionType === 'bonus') {
                // Show only bonus action spells
                const bonusSpells = getBonusActionSpells(profile);
                if (bonusSpells.length === 0) {
                    html += '<div class="detail-content"><p class="muted-center">No bonus action spells available.</p></div>';
                } else {
                    // Sort bonus action spells alphabetically
                    const sortedSpells = [...bonusSpells].sort((a, b) => a.localeCompare(b));
                    html += '<div class="spells-section">';
                    html += '<div class="spells-section-title">‚ú® Bonus Action Spells</div>';
                    html += '<div class="spells-list">';
                    sortedSpells.forEach(spell => {
                        // Find spell level (assume level 1 for now, could be enhanced)
                        const level = 1;
                        html += `<div class="spell-item" onclick="handleSpellCast('${spell.replace(/'/g, "\\'")}', ${level}, 'bonus')">${spell}</div>`;
                    });
                    html += '</div>';
                    html += '</div>';
                }
            } else {
                // Show cantrips and action spells
                if (hasCantrips) {
                    html += '<div class="spells-section">';
                    html += '<div class="spells-section-title">‚ú® Cantrips</div>';
                    html += '<div class="spells-list">';
                    const sortedCantrips = [...profile.cantrips].sort((a, b) => a.localeCompare(b));
                    sortedCantrips.forEach(spell => {
                        html += `<div class="spell-item" onclick="handleSpellCast('${spell.replace(/'/g, "\\'")}', 0, 'action')">${spell}</div>`;
                    });
                    html += '</div>';
                    html += '</div>';
                }

                // Show action spells by level
                if (hasSpellSlots) {
                    const spellLevels = Object.keys(profile.spellSlots)
                        .map(level => parseInt(level, 10))
                        .filter(level => level >= 1 && level <= 9)
                        .sort((a, b) => a - b);

                    spellLevels.forEach(level => {
                        const totalSlots = profile.spellSlots[level] || 0;
                        const usedSlots = state.spellSlotsUsed[level] || 0;
                        const remainingSlots = totalSlots - usedSlots;

                        // Get action spells for this level
                        const actionSpells = getActionSpells(profile);
                        if (actionSpells.length === 0 && level === 1) return; // Skip if no action spells

                        html += '<div class="spells-section">';
                        html += `<div class="spells-section-title">Level ${level}`;
                        if (totalSlots > 0) {
                            html += ` <span class="spell-slots-info">`;
                            if (remainingSlots > 0) {
                                html += `<span class="spell-slots-remaining">${remainingSlots}/${totalSlots} slots remaining</span>`;
                            } else {
                                html += `<span class="spell-slots-empty">0/${totalSlots} slots remaining</span>`;
                            }
                            html += `</span>`;
                        }
                        html += '</div>';

                        if (level === 1 && actionSpells.length > 0) {
                            html += '<div class="spells-list">';
                            const sortedSpells = [...actionSpells].sort((a, b) => a.localeCompare(b));
                            sortedSpells.forEach(spell => {
                                html += `<div class="spell-item" onclick="handleSpellCast('${spell.replace(/'/g, "\\'")}', ${level}, 'action')">${spell}</div>`;
                            });
                            html += '</div>';
                        } else if (level > 1) {
                            html += '<div class="spells-list">';
                            html += '<div class="spell-item" style="color: var(--text-light); font-style: italic;">No spells of this level</div>';
                            html += '</div>';
                        }
                        html += '</div>';
                    });
                } else if (profile.spells && profile.spells.length > 0) {
                    // If no spell slots but has spells, show action spells under Level 1
                    const actionSpells = getActionSpells(profile);
                    if (actionSpells.length > 0) {
                        html += '<div class="spells-section">';
                        html += '<div class="spells-section-title">Level 1</div>';
                        html += '<div class="spells-list">';
                        const sortedSpells = [...actionSpells].sort((a, b) => a.localeCompare(b));
                        sortedSpells.forEach(spell => {
                            html += `<div class="spell-item" onclick="handleSpellCast('${spell.replace(/'/g, "\\'")}', 1, 'action')">${spell}</div>`;
                        });
                        html += '</div>';
                        html += '</div>';
                    }
                }
            }

            content.innerHTML = html;
            showScreen(screenId);
        }

        // Pending spell cast (stored while waiting for slot confirmation)
        let pendingSpellCast = null;

        // Handle spell cast
        function handleSpellCast(spellName, level, actionType) {
            // level 0 = cantrip, level >= 1 = leveled spell (from UI)
            // actionType = 'action' or 'bonus'
            // Resolve actual level from profile so cantrips never consume slots.
            const profile = getActiveCharacterProfile();
            let actualLevel = getSpellLevelForSlot(spellName, profile);
            if (profile && profile.cantrips && profile.cantrips.some(c => String(c).trim().toLowerCase() === String(spellName).trim().toLowerCase())) {
                actualLevel = 0;
            }

            if (actualLevel === 0) {
                // Cantrip - no slot needed, just log it and mark action as used
                logSpellCast(spellName, 0);
                if (actionType === 'action') {
                    state.action = 'used';
                    state.actionUsedBy = 'spell';
                } else if (actionType === 'bonus') {
                    state.bonusAction = 'used';
                }
                saveState();
                updateUI();
                showToast(`Cast: ${spellName}`);
                showScreen('screen-home');
                return;
            }

            // Leveled spell - check for free cast (X/LR, X/SR) before slot
            const freeInfo = getSpellFreeCastInfo(spellName, profile);
            if (freeInfo && freeInfo.freeUsesRemaining > 0) {
                pendingSpellCast = {
                    spellName,
                    level: actualLevel,
                    actionType,
                    isFreeCast: true,
                    freeUseRestType: freeInfo.freeUseRestType,
                    freeUsesRemaining: freeInfo.freeUsesRemaining
                };
                if (prefs.confirmSpends) {
                    const dialog = document.getElementById('spell-slot-dialog');
                    const message = document.getElementById('spell-slot-dialog-message');
                    message.textContent = `Use free cast of ${spellName}? (${freeInfo.freeUsesRemaining}/${freeInfo.freeUsesMax} ${freeInfo.freeUseRestType} remaining)`;
                    dialog.classList.add('active');
                } else {
                    confirmSpellSlotSpend();
                }
                return;
            }

            // Leveled spell - use slot
            if (!profile || !profile.spellSlots || !profile.spellSlots[actualLevel]) {
                showToast(`No spell slots available for level ${actualLevel}`);
                return;
            }

            const totalSlots = profile.spellSlots[actualLevel] || 0;
            const usedSlots = state.spellSlotsUsed[actualLevel] || 0;
            const remainingSlots = totalSlots - usedSlots;

            if (remainingSlots <= 0) {
                showToast(`No level ${actualLevel} spell slots remaining`);
                return;
            }

            pendingSpellCast = { spellName, level: actualLevel, actionType };

            if (prefs.confirmSpends) {
                const dialog = document.getElementById('spell-slot-dialog');
                const message = document.getElementById('spell-slot-dialog-message');
                message.textContent = `Cast ${spellName}? Spend a level ${actualLevel} spell slot? (${remainingSlots - 1}/${totalSlots} remaining)`;
                dialog.classList.add('active');
            } else {
                confirmSpellSlotSpend();
            }
        }

        // Confirm spell slot spending (or free cast)
        function confirmSpellSlotSpend() {
            if (!pendingSpellCast) return;

            const { spellName, level, actionType, isFreeCast, freeUseRestType, freeUsesRemaining } = pendingSpellCast;

            if (isFreeCast) {
                const characterId = getActiveCharacterId();
                const next = Math.max(0, (freeUsesRemaining || 0) - 1);
                setSpellFreeUsesRemaining(characterId, spellName, next);

                if (actionType === 'action') {
                    state.action = 'used';
                    state.actionUsedBy = 'spell';
                } else if (actionType === 'bonus') {
                    state.bonusAction = 'used';
                }
                logSpellCast(spellName, level);
                saveState();
                closeSpellSlotDialog();
                updateUI();
                const profile = getActiveCharacterProfile();
                const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
                const spell = normalized.find(s => s.name === spellName);
                const max = spell?.freeUsesMax ?? 1;
                showToast(`Cast: ${spellName} (${next}/${max} ${freeUseRestType} remaining)`);
                pendingSpellCast = null;
                showScreen('screen-home');
                return;
            }

            // Decrement slot
            if (!state.spellSlotsUsed[level]) {
                state.spellSlotsUsed[level] = 0;
            }
            state.spellSlotsUsed[level]++;

            if (actionType === 'action') {
                state.action = 'used';
                state.actionUsedBy = 'spell';
            } else if (actionType === 'bonus') {
                state.bonusAction = 'used';
            }
            logSpellCast(spellName, level);
            saveState();
            closeSpellSlotDialog();
            updateUI();

            const profile = getActiveCharacterProfile();
            const totalSlots = profile?.spellSlots?.[level] || 0;
            const usedSlots = state.spellSlotsUsed[level] || 0;
            const remainingSlots = totalSlots - usedSlots;
            showToast(`Cast: ${spellName} (${remainingSlots}/${totalSlots} slots remaining)`);

            pendingSpellCast = null;
            showScreen('screen-home');
        }

        // Cancel spell slot spending
        function cancelSpellSlotSpend() {
            closeSpellSlotDialog();
            pendingSpellCast = null;
        }

        // Close spell slot dialog
        function closeSpellSlotDialog() {
            document.getElementById('spell-slot-dialog').classList.remove('active');
        }

        // Log spell cast to turn log
        function logSpellCast(spellName, level) {
            const entry = {
                action: 'cast',
                spell: spellName,
                level: level
            };

            // Add timestamp if enabled (default: enabled)
            if (prefs.turnLogTimestamps !== false) {
                const now = new Date();
                entry.timestamp = now.toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit' 
                });
            }

            state.turnLog.push(entry);
            saveState();
            updateTurnLog();
        }

        // Update turn log display
        function updateTurnLog() {
            const turnLogContainer = document.getElementById('turn-log');
            const turnLogEntries = document.getElementById('turn-log-entries');

            if (!turnLogContainer || !turnLogEntries) return;

            if (state.turnLog && state.turnLog.length > 0) {
                turnLogContainer.style.display = 'block';
                let html = '';
                state.turnLog.forEach(entry => {
                    if (entry.action === 'cast') {
                        const levelText = entry.level === 0 ? 'Cantrip' : `Level ${entry.level}`;
                        html += `<div class="turn-log-entry">`;
                        if (entry.timestamp) {
                            html += `<span class="turn-log-entry-time">${entry.timestamp}</span>`;
                        }
                        html += `<span>‚ú® Cast ${entry.spell} (${levelText})</span>`;
                        html += `</div>`;
                    }
                });
                turnLogEntries.innerHTML = html;
            } else {
                turnLogContainer.style.display = 'none';
            }
        }

        // Clear turn log
        function clearTurnLog() {
            if (confirm('Clear turn log?')) {
                state.turnLog = [];
                saveState();
                updateTurnLog();
            }
        }

        // Update speed display in Move modal
        function updateMoveSpeedDisplay() {
            const speedDisplay = document.getElementById('move-speed-display');
            const speedNumber = document.getElementById('move-speed-number');
            const speedType = document.getElementById('move-speed-type');
            const descriptionText = document.getElementById('move-description-text');
            
            if (!speedDisplay || !speedNumber || !speedType || !descriptionText) return;
            
            // Try to get speed from active character profile
            let speed = null;
            try {
                const profile = getActiveCharacterProfile();
                if (profile && profile.speed !== undefined && profile.speed !== null) {
                    speed = profile.speed;
                }
            } catch (e) {
                // Ignore errors
            }
            
            if (speed !== null && speed > 0) {
                // Show speed display and update values
                speedDisplay.style.display = 'block';
                speedNumber.textContent = speed;
                speedType.textContent = 'Walking';
                
                // Update description text with actual speed
                descriptionText.textContent = `On your turn, you can move a distance up to your speed. You can use some of your movement before and after your action. For example, if you have a speed of ${speed} feet, you can move ${Math.floor(speed / 3)} feet, take your action, and then move ${Math.floor(speed * 2 / 3)} feet more.`;
            } else {
                // Hide speed display if no speed available
                speedDisplay.style.display = 'none';
                descriptionText.textContent = 'On your turn, you can move a distance up to your speed. You can use some of your movement before and after your action. For example, if you have a speed of 30 feet, you can move 10 feet, take your action, and then move 20 feet more.';
            }
        }

        // Toast Notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);
        }

        // MOVE
        function handleMove() {
            if (state.movement === 'used') {
                showToast('Movement already used.');
                return;
            }
            state.pendingAction = 'move';
            if (prefs.confirmSpends) {
                showScreen('screen-move-detail');
            } else {
                confirmMove();
            }
        }

        // DASH
        function handleDash() {
            if (state.action === 'used') {
                showToast('Action already used.');
                return;
            }
            state.pendingAction = 'dash';
            if (prefs.confirmSpends) {
                showScreen('screen-dash-detail');
            } else {
                confirmDash();
            }
        }

        // Handle Action Click (with check)
        function handleActionClick() {
            if (state.action === 'used') {
                showToast('Action already used.');
                return;
            }
            showScreen('screen-action');
        }

        // Handle Bonus Action Click (with check)
        function handleBonusActionClick() {
            if (state.bonusAction === 'used') {
                showToast('Bonus Action already used.');
                return;
            }
            if (!hasBonusActionOptions()) {
                showToast('No bonus actions configured.');
                return;
            }
            renderBonusActionOptions();
            showScreen('screen-bonus-action');
        }

        // Handle Interact Click (with check)
        function handleInteractClick() {
            if (state.interaction === 'used') {
                showToast('Interaction already used.');
                return;
            }
            showScreen('screen-interact');
        }

        function renderBonusActionOptions() {
            const container = document.getElementById('bonus-action-options');
            if (!container) return;
            container.innerHTML = '';

            const options = getBonusActionOptions();
            
            // Check if character has bonus action spells
            const profile = getActiveCharacterProfile();
            const hasBonusActionSpells = profile && getBonusActionSpells(profile).length > 0;
            
            if (hasBonusActionSpells) {
                const btn = document.createElement('button');
                btn.className = 'btn btn-primary';
                btn.type = 'button';
                btn.textContent = '‚ú® Cast a Spell';
                btn.onclick = () => showSpellSelection('bonus');
                container.appendChild(btn);
            }

            if (options.length === 0 && !hasBonusActionSpells) {
                const wrap = document.createElement('div');
                wrap.className = 'detail-content';
                wrap.innerHTML = '<p class="muted-center">All set.</p>';
                container.appendChild(wrap);
                return;
            }

            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'btn btn-primary';
                btn.type = 'button';
                btn.textContent = opt.label;
                btn.onclick = () => showBonusActionDetail(opt.key);
                container.appendChild(btn);
            });
        }

        // Confirm Move
        function confirmMove() {
            state.movement = 'used';
            state.pendingAction = null;
            updateUI();
            showScreen('screen-home');
        }

        // Confirm Dash
        function confirmDash() {
            state.action = 'used';
            state.dashActive = true;
            state.actionUsedBy = 'dash';
            state.pendingAction = null;
            updateUI();
            showScreen('screen-home');
        }

        // INTERACT
        function handleInteract(type) {
            state.pendingAction = 'interact';
            state.pendingInteractType = type;
            
            const interactDetails = {
                'draw-stow': {
                    title: 'üó°Ô∏è Draw/Stow Weapon',
                    content: '<p><strong>Draw or sheathe one weapon.</strong></p><p>You can interact with one object or feature of the environment for free during your move or action. For example, you could open a door during your move as you stride toward a foe, or you could draw your weapon as part of the same action you use to attack.</p><p>If you want to interact with a second object, you need to use your action. Some magic items and other special objects always require an action to use, as stated in their descriptions.</p>'
                },
                'door': {
                    title: 'üö™ Open/Close Door',
                    content: '<p><strong>Open or close an unlocked door.</strong></p><p>You can interact with one object or feature of the environment for free during your move or action. Opening or closing a door is a common example of this type of interaction.</p><p>If you want to interact with a second object, you need to use your action.</p>'
                },
                'pickup-drop': {
                    title: 'üì¶ Pick Up / Drop Item',
                    content: '<p><strong>Pick up an item from ground or drop held item.</strong></p><p>You can interact with one object or feature of the environment for free during your move or action. Picking up or dropping an item is a common example of this type of interaction.</p><p>Dropping an item is always free. Picking up an item is a free object interaction, but only one per turn.</p><p>If you want to interact with a second object, you need to use your action.</p>'
                },
                'move-object': {
                    title: 'ü™ë Move Small Object',
                    content: '<p><strong>Move a chair, table, or small object to create cover or clear a path.</strong></p><p>You can interact with one object or feature of the environment for free during your move or action. Moving a small object like a chair or table is a common example of this type of interaction.</p><p>This can be used to create cover, block a doorway, or clear a path. If you want to interact with a second object, you need to use your action.</p>'
                }
            };

            const detail = interactDetails[type];
            if (detail) {
                if (prefs.confirmSpends) {
                    document.getElementById('interact-detail-title').textContent = detail.title;
                    document.getElementById('interact-detail-content').innerHTML = detail.content;
                    showScreen('screen-interact-detail');
                } else {
                    confirmInteract();
                }
            }
        }

        // Confirm Interact
        function confirmInteract() {
            state.interaction = 'used';
            state.pendingAction = null;
            state.pendingInteractType = null;
            updateUI();
            showScreen('screen-home');
        }

        // Toggle Reaction
        function toggleReaction() {
            // Can't toggle if reserved (from Ready action)
            if (state.reaction === 'reserved') {
                return;
            }
            
            // Toggle between available and used
            if (state.reaction === 'available') {
                state.reaction = 'used';
            } else if (state.reaction === 'used') {
                state.reaction = 'available';
            }
            
            // Update reaction widget and save state
            updateReactionWidget();
            saveState();
        }

        // Per-button undo handlers
        function handleUndoMove() {
            if (confirm('Undo MOVE?')) {
                state.movement = 'available';
                updateUI();
            }
        }
        
        function handleUndoDash() {
            if (confirm('Undo DASH?')) {
                state.action = 'available';
                state.dashActive = false;
                state.actionUsedBy = null;
                updateUI();
            }
        }
        
        function handleUndoAction() {
            if (confirm('Undo ACTION?')) {
                // If action was used for dash, clear dashActive
                if (state.actionUsedBy === 'dash') {
                    state.dashActive = false;
                }
                // If reaction is reserved (from Ready action), restore it
                if (state.reaction === 'reserved') {
                    state.reaction = 'available';
                }
                state.action = 'available';
                state.actionUsedBy = null;
                updateUI();
            }
        }
        
        function handleUndoBonusAction() {
            if (confirm('Undo BONUS ACTION?')) {
                state.bonusAction = 'available';
                updateUI();
            }
        }
        
        function handleUndoInteract() {
            if (confirm('Undo INTERACT?')) {
                state.interaction = 'available';
                updateUI();
            }
        }

        // Confirm Action Detail
        function confirmActionDetail() {
            if (state.pendingActionType === 'ready') {
                state.action = 'used';
                state.reaction = 'reserved';
            } else {
                state.action = 'used';
            }
            
            state.actionUsedBy = 'other';

            state.pendingAction = null;
            state.pendingActionType = null;
            updateUI();
            showScreen('screen-home');
        }

        // Action Details
        const actionDetails = {
            'search': {
                title: 'üîç Search',
                content: '<p><strong>Make a Perception or Investigation check to find hidden objects, creatures, or details.</strong></p><p>When you take the Search action, you devote your attention to finding something. Depending on the nature of your search, the DM might have you make a Wisdom (Perception) check or an Intelligence (Investigation) check.</p>'
            },
            'ready': {
                title: '‚è≥ Ready',
                content: '<p><strong>Hold your action until a trigger occurs. Uses your reaction when triggered.</strong></p><p>Sometimes you want to get the jump on a foe or wait for a particular circumstance before you act. To do so, you can take the Ready action on your turn, which lets you act using your reaction before the start of your next turn.</p><p>First, you decide what perceivable circumstance will trigger your reaction. Then, you choose the action you will take in response to that trigger, or you choose to move up to your speed in response to it. Examples include "If the cultist steps on the trapdoor, I\'ll pull the lever that opens it," and "If the goblin steps next to me, I move away."</p><p><strong>When the trigger occurs, you can either take your reaction right after the trigger finishes or ignore the trigger. Remember that you can take only one reaction per round.</strong></p>'
            },
            'help': {
                title: 'ü§ù Help',
                content: '<p><strong>Grant advantage to an ally\'s next ability check or attack roll against a target within 5 feet.</strong></p><p>You can lend your aid to another creature in the completion of a task. When you take the Help action, the creature you aid gains advantage on the next ability check it makes to perform the task you are helping with, provided that it makes the check before the start of your next turn.</p><p>Alternatively, you can aid a friendly creature in attacking a creature within 5 feet of you. You feint, distract the target, or in some other way team up to make your ally\'s attack more effective. If your ally attacks the target before your next turn, the first attack roll is made with advantage.</p>'
            },
            'dodge': {
                title: 'üõ°Ô∏è Dodge',
                content: '<p><strong>Impose disadvantage on attack rolls against you. Dex saves with advantage until start of next turn.</strong></p><p>When you take the Dodge action, you focus entirely on avoiding attacks. Until the start of your next turn, any attack roll made against you has disadvantage if you can see the attacker, and you make Dexterity saving throws with advantage. You lose this benefit if you are incapacitated or if your speed drops to 0.</p>'
            },
            'disengage': {
                title: 'üèÉ‚Äç‚ôÇÔ∏è Disengage',
                content: '<p><strong>Your movement doesn\'t provoke opportunity attacks this turn.</strong></p><p>If you take the Disengage action, your movement doesn\'t provoke opportunity attacks for the rest of the turn.</p>'
            },
            'hide': {
                title: 'ü•∑ Hide',
                content: '<p><strong>Make a Dexterity (Stealth) check to become hidden. Must be behind cover or heavily obscured.</strong></p><p>When you take the Hide action, you make a Dexterity (Stealth) check in an attempt to hide, following the rules for hiding. If you succeed, you gain certain benefits, as described in the "Unseen Attackers and Targets" section later in this chapter.</p><p>You can\'t hide from a creature that can see you, and if you make noise (such as shouting a warning or knocking over a vase), you give away your position. An invisible creature can\'t be seen, so it can always try to hide. Signs of its passage might still be noticed, however, and it still has to stay quiet.</p><p>In combat, most creatures stay alert for signs of danger all around, so if you come out of hiding and approach a creature, it usually sees you. However, under certain circumstances, the DM might allow you to stay hidden as you approach a creature that is distracted, allowing you to gain advantage on an attack before you are seen.</p>'
            },
            'use-object': {
                title: 'üîß Use Object (Complex)',
                content: '<p><strong>Complex object use - potion, device, tool, DM call.</strong></p><p>You normally interact with an object while doing something else, such as when you draw a sword as part of an attack. When an object requires your action for its use, you take the Use an Object action. This action is also useful when you want to interact with more than one object on your turn.</p><p>Some magic items and other special objects always require an action to use, as stated in their descriptions.</p><p><strong>This is separate from your free object interaction (INTERACT). Examples include drinking a potion, activating a magic item, using a device, or other complex object interactions as determined by the DM.</strong></p>'
            },
            'cast-spell': {
                title: '‚ú® Cast a Spell',
                content: '<p><strong>Cast a spell with casting time of 1 action.</strong></p><p>Spellcasters such as wizards and clerics, as well as many monsters, have access to spells and can use them to great effect in combat. Each spell has a casting time, which specifies whether the caster must use an action, a reaction, minutes, or even hours to cast the spell. Casting a spell is, therefore, not necessarily an action. Most spells have a casting time of 1 action, so a spellcaster often uses his or her action in combat to cast such a spell.</p>'
            },
            'shove': {
                title: 'üí™ Shove',
                content: '<p><strong>Make a Strength (Athletics) contest. On success, push target 5 feet away or knock prone.</strong></p><p>Using the Attack action, you can make a special melee attack to shove a creature, either to knock it prone or push it away from you. If you\'re able to make multiple attacks with the Attack action, this attack replaces one of them.</p><p>The target must be no more than one size larger than you and must be within your reach. Instead of making an attack roll, you make a Strength (Athletics) check contested by the target\'s Strength (Athletics) or Dexterity (Acrobatics) check (the target chooses the ability to use). If you win the contest, you either knock the target prone or push it 5 feet away from you.</p>'
            },
            'grapple': {
                title: 'ü§º Grapple',
                content: '<p><strong>Make a Strength (Athletics) contest. On success, target is grappled (speed becomes 0).</strong></p><p>Using the Attack action, you can make a special melee attack to grapple a creature. If you\'re able to make multiple attacks with the Attack action, this attack replaces one of them.</p><p>The target of your grapple must be no more than one size larger than you and must be within your reach. Using at least one free hand, you try to seize the target by making a grapple check instead of an attack roll: a Strength (Athletics) check contested by the target\'s Strength (Athletics) or Dexterity (Acrobatics) check (the target chooses the ability to use). If you succeed, you subject the target to the grappled condition. The condition specifies the things that end it, and you can release the target whenever you like (no action required).</p>'
            }
        };

        function showActionDetail(actionType) {
            const detail = actionDetails[actionType];
            if (detail) {
                state.pendingAction = 'action';
                state.pendingActionType = actionType;
                if (prefs.confirmSpends) {
                    document.getElementById('action-detail-title').textContent = detail.title;
                    document.getElementById('action-detail-content').innerHTML = detail.content;
                    showScreen('screen-action-detail');
                } else {
                    confirmActionDetail();
                }
            }
        }

        // Bonus Action Details
        const bonusActionDetails = {
            'healing-word': {
                title: 'üíö Healing Word',
                content: '<p><strong>Cast Healing Word as a bonus action. Target regains hit points.</strong></p><p>A creature of your choice that you can see within range regains hit points equal to 1d4 + your spellcasting ability modifier. This spell has no effect on undead or constructs.</p><p><strong>At Higher Levels:</strong> When you cast this spell using a spell slot of 2nd level or higher, the healing increases by 1d4 for each slot level above 1st.</p>'
            },
            'class-feature': {
                title: 'üé≠ Class Feature',
                content: '<p><strong>Use a class feature that takes a bonus action.</strong></p><p>Various class features can be used as a bonus action. Examples include:</p><ul><li><strong>Rogue - Cunning Action:</strong> Dash, Disengage, or Hide as a bonus action</li><li><strong>Barbarian - Rage:</strong> Enter a rage as a bonus action</li><li><strong>Monk - Flurry of Blows:</strong> Make unarmed strikes as a bonus action</li><li><strong>Ranger - Hunter\'s Mark:</strong> Cast Hunter\'s Mark as a bonus action</li></ul><p>Consult your class features for other bonus action options available to you.</p>'
            },
            'offhand-attack': {
                title: 'üó°Ô∏è Offhand Attack',
                content: '<p><strong>Make an attack with a light weapon in your off hand.</strong></p><p>When you take the Attack action and attack with a light melee weapon that you\'re holding in one hand, you can use a bonus action to attack with a different light melee weapon that you\'re holding in the other hand. You don\'t add your ability modifier to the damage of the bonus attack, unless that modifier is negative.</p><p>If either weapon has the thrown property, you can throw the weapon, instead of making a melee attack with it.</p><p><strong>Two-Weapon Fighting Style:</strong> If you have the Two-Weapon Fighting style, you can add your ability modifier to the damage of the bonus attack.</p>'
            }
        };

        function showBonusActionDetail(bonusType) {
            let detail = bonusActionDetails[bonusType];
            if (bonusType === 'class-feature') {
                detail = getClassFeatureBonusAction();
            }
            if (detail) {
                state.pendingAction = 'bonus-action';
                state.pendingBonusActionType = bonusType;
                if (prefs.confirmSpends) {
                    document.getElementById('bonus-action-detail-title').textContent = detail.title;
                    document.getElementById('bonus-action-detail-content').innerHTML = detail.content;
                    showScreen('screen-bonus-action-detail');
                } else {
                    confirmBonusAction();
                }
            } else {
                showToast('No class bonus action configured.');
            }
        }

        // Confirm Bonus Action
        function confirmBonusAction() {
            state.bonusAction = 'used';
            state.pendingAction = null;
            state.pendingBonusActionType = null;
            updateUI();
            showScreen('screen-home');
        }

        // Attack Tree
        function showAttackTree() {
            state.pendingAction = 'attack';
            state.currentAttackStep = 1;
            showScreen('screen-attack');
            
            // Hide all attack steps first
            document.querySelectorAll('.attack-tree').forEach(step => {
                step.classList.remove('active');
            });
            
            // Show first step
            document.getElementById('attack-step-1').classList.add('active');
        }

        function showAttackStep(step, type) {
            // Hide all attack steps
            document.querySelectorAll('.attack-tree').forEach(step => {
                step.classList.remove('active');
            });

            if (step === 1) {
                document.getElementById('attack-step-1').classList.add('active');
                state.currentAttackStep = 1;
            } else if (step === 2) {
                if (type === 'weapon') {
                    document.getElementById('attack-weapon').classList.add('active');
                    state.lastAttackType = 'weapon';
                    // Show/hide Extra Attack reminder based on setting
                    const extraAttackReminder = document.getElementById('extra-attack-reminder');
                    if (extraAttackReminder) {
                        extraAttackReminder.style.display = prefs.extraAttackReminder ? 'block' : 'none';
                    }
                } else if (type === 'spell') {
                    document.getElementById('attack-spell').classList.add('active');
                    state.lastAttackType = 'spell';
                } else if (type === 'save') {
                    document.getElementById('attack-save-type').classList.add('active');
                    state.lastAttackType = 'save';
                } else if (type && type.startsWith('save-')) {
                    const saveType = type.replace('save-', '').toUpperCase();
                    document.getElementById('save-type-name').textContent = saveType;
                    document.getElementById('attack-save-result').classList.add('active');
                    state.lastAttackType = type; // Store the save ability type
                }
                state.currentAttackStep = 2;
            } else if (step === 3) {
                // Combined hit/miss/save result screen
                const resultContent = document.getElementById('attack-result-content');
                if (type === 'hit') {
                    resultContent.innerHTML = '<p><strong>Roll damage dice + modifier</strong></p>';
                    // Show Extra Attack reminder if enabled
                    if (prefs.extraAttackReminder) {
                        resultContent.innerHTML += '<div style="margin-top: 1rem; padding: 0.75rem; background-color: rgba(0, 0, 0, 0.05); border-radius: 4px;"><p style="margin-bottom: 0.5rem; font-weight: 600;">Extra Attack Reminder:</p><p style="margin: 0.25rem 0;">If you have Extra Attack, you can make another attack.</p></div>';
                    }
                } else if (type === 'miss') {
                    resultContent.innerHTML = '<p><strong>Miss!</strong></p><p><strong>Follow-up suggestions:</strong></p><ul><li>Move to better position or cover</li><li>Help an ally on your next turn</li><li>Try Shove to push or knock prone</li><li>Try Grapple to restrain target</li><li>Use environment (close door, tip table for cover)</li></ul>';
                } else if (type === 'save-succeeds') {
                    resultContent.innerHTML = '<p><strong>Save Succeeds:</strong> Reduced or no effect (as per spell)</p>';
                } else if (type === 'save-fails') {
                    resultContent.innerHTML = '<p><strong>Save Fails:</strong> Full effect applied</p>';
                }
                document.getElementById('attack-result').classList.add('active');
                state.currentAttackStep = 3;
            }
        }

        function attackStep(step, type) {
            showAttackStep(step, type);
        }

        // Handle back button from attack result screen
        function goBackFromAttackResult() {
            if (state.lastAttackType && state.lastAttackType.startsWith('save-')) {
                // For save attacks, go back to save result screen
                attackStep(2, state.lastAttackType);
            } else if (state.lastAttackType === 'weapon' || state.lastAttackType === 'spell') {
                // For weapon/spell attacks, go back to weapon/spell screen
                attackStep(2, state.lastAttackType);
            } else {
                // Fallback to step 1
                attackStep(1);
            }
        }

        // Confirm Attack Action
        function confirmAttackAction() {
            state.action = 'used';
            state.actionUsedBy = 'other';
            state.pendingAction = null;
            updateUI();
            showScreen('screen-home');
        }

        // End Turn - Streamlined: go directly to checklist, show quick actions there if needed
        function handleEndTurn() {
            proceedToEndTurnScreen();
        }

        function proceedToEndTurnScreen() {
            // Update checklist
            document.getElementById('checklist-movement').textContent = state.movement === 'used' ? 'Used' : 'Unused';
            document.getElementById('checklist-movement').className = 'status ' + (state.movement === 'used' ? 'used' : 'unused');
            document.getElementById('checklist-action').textContent = state.action === 'used' ? 'Used' : 'Unused';
            document.getElementById('checklist-action').className = 'status ' + (state.action === 'used' ? 'used' : 'unused');
            
            // Only show Bonus Action in checklist if enabled
            const bonusActionItem = document.getElementById('checklist-bonus-action').parentElement;
            if (prefs.bonusActionEnabled && hasBonusActionOptions()) {
                bonusActionItem.style.display = '';
                document.getElementById('checklist-bonus-action').textContent = state.bonusAction === 'used' ? 'Used' : 'Unused';
                document.getElementById('checklist-bonus-action').className = 'status ' + (state.bonusAction === 'used' ? 'used' : 'unused');
            } else {
                bonusActionItem.style.display = 'none';
            }
            
            // Only show Interaction in checklist if tracking is enabled
            const interactionItem = document.getElementById('checklist-interaction-item');
            if (prefs.trackInteraction) {
                interactionItem.style.display = '';
                document.getElementById('checklist-interaction').textContent = state.interaction === 'used' ? 'Used' : 'Unused';
                document.getElementById('checklist-interaction').className = 'status ' + (state.interaction === 'used' ? 'used' : 'unused');
            } else {
                interactionItem.style.display = 'none';
            }
            
            // Show quick actions if resources are available
            const resources = countAvailableResources();
            const quickActionsEl = document.getElementById('end-turn-quick-actions');
            const quickButtonsEl = document.getElementById('end-turn-quick-buttons');
            
            if (resources.count > 0 && quickActionsEl && quickButtonsEl) {
                quickButtonsEl.innerHTML = '';
                
                if (state.movement === 'available') {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-secondary btn-small';
                    btn.textContent = 'Mark Movement Used';
                    btn.onclick = () => {
                        state.movement = 'used';
                        updateUI();
                        proceedToEndTurnScreen(); // Refresh
                    };
                    quickButtonsEl.appendChild(btn);
                }
                
                if (prefs.trackInteraction && state.interaction === 'available') {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-secondary btn-small';
                    btn.textContent = 'Mark Interaction Used';
                    btn.onclick = () => {
                        state.interaction = 'used';
                        updateUI();
                        proceedToEndTurnScreen(); // Refresh
                    };
                    quickButtonsEl.appendChild(btn);
                }
                
                if (prefs.bonusActionEnabled && state.bonusAction === 'available' && hasBonusActionOptions()) {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-secondary btn-small';
                    btn.textContent = 'Mark Bonus Action Used';
                    btn.onclick = () => {
                        state.bonusAction = 'used';
                        updateUI();
                        proceedToEndTurnScreen(); // Refresh
                    };
                    quickButtonsEl.appendChild(btn);
                }
                
                quickActionsEl.style.display = quickButtonsEl.children.length > 0 ? 'block' : 'none';
            } else if (quickActionsEl) {
                quickActionsEl.style.display = 'none';
            }
            
            showScreen('screen-end-turn');
        }

        function closeEndTurnDialog() {
            document.getElementById('end-turn-dialog').classList.remove('active');
        }

        function confirmEndTurnAnyway() {
            closeEndTurnDialog();
            proceedToEndTurnScreen();
        }

        function confirmEndTurn() {
            // Reset resources
            state.movement = 'available';
            state.action = 'available';
            state.bonusAction = 'available';
            state.interaction = 'available';
            // Reaction does NOT reset (resets at START of turn)
            state.dashActive = false;
            state.actionUsedBy = null;
            // Spell slots do NOT reset (they reset on long rest, not end of turn)

            updateUI();
            showScreen('screen-not-your-turn');
        }

        // Start Turn
        function handleStartTurn() {
            // Reset reaction at START of turn (per 5e rules)
            if (state.reaction === 'reserved') {
                state.reaction = 'available';
            } else {
                state.reaction = 'available';
            }
            
            // Auto-reset resources if setting is enabled
            if (prefs.autoResetOnStartTurn) {
                state.movement = 'available';
                state.action = 'available';
                state.bonusAction = 'available';
                state.interaction = 'available';
                state.dashActive = false;
                state.actionUsedBy = null;
                // Note: Spell slots are NOT reset on start turn (they reset on long rest)
            }
            
            updateUI();
            showScreen('screen-home');
        }

        // Reset All
        function showResetDialog() {
            document.getElementById('reset-dialog').classList.add('active');
        }

        function closeResetDialog() {
            document.getElementById('reset-dialog').classList.remove('active');
        }

        function resetFreeUsesForRest(restType) {
            const profile = getActiveCharacterProfile();
            const characterId = getActiveCharacterId();
            if (!profile || !characterId) return;
            const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
            const map = loadSpellFreeUsesState();
            if (!map[characterId]) map[characterId] = {};
            let changed = false;
            normalized.forEach(spell => {
                if (spell.freeUseRestType === restType && spell.freeUsesMax > 0) {
                    map[characterId][spell.name] = spell.freeUsesMax;
                    changed = true;
                }
            });
            if (changed) saveSpellFreeUsesState(map);
        }

        function handleLongRest() {
            resetFreeUsesForRest('LR');
            state.spellSlotsUsed = {};
            saveState();
            closeResetDialog();
            updateUI();
            showToast('Long rest: spell slots and 1/LR free casts restored');
        }

        function handleShortRest() {
            resetFreeUsesForRest('SR');
            closeResetDialog();
            updateUI();
            showToast('Short rest: 1/SR free casts restored');
        }

        function confirmReset() {
            // Clear localStorage
            localStorage.removeItem('combatTurnState');
            
            // Reset state to defaults
            state = {
                movement: 'available',
                action: 'available',
                bonusAction: 'available',
                interaction: 'available',
                reaction: 'available',
                dashActive: false,
                actionUsedBy: null,
                currentAttackStep: 1,
                currentSaveType: null,
                pendingAction: null,
                spellSlotsUsed: {},  // Reset spell slots usage
                turnLog: []  // Reset turn log
            };
            
            // Update UI and go to home
            updateUI();
            closeResetDialog();
            showScreen('screen-home');
        }

        // PDF Import Functions
        let pendingCharacterProfile = null;

        // Active Character Management
        const ACTIVE_CHARACTER_ID_KEY = 'activeCharacterId';
        const CHARACTER_PROFILE_PREFIX = 'characterProfileV1:';

        // Generate a unique character ID
        function generateCharacterId() {
            return 'char_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Get active character ID
        function getActiveCharacterId() {
            return localStorage.getItem(ACTIVE_CHARACTER_ID_KEY);
        }

        // Set active character ID
        function setActiveCharacterId(id) {
            localStorage.setItem(ACTIVE_CHARACTER_ID_KEY, id);
        }

        // Get active character profile
        function getActiveCharacterProfile() {
            const activeId = getActiveCharacterId();
            if (activeId) {
                try {
                    const profileData = localStorage.getItem(CHARACTER_PROFILE_PREFIX + activeId);
                    if (profileData) {
                        return JSON.parse(profileData);
                    }
                } catch (e) {
                    console.error('Failed to load active character profile:', e);
                }
            }
            
            // Backward compatibility: migrate old 'characterProfile' if it exists
            try {
                const oldProfile = localStorage.getItem('characterProfile');
                if (oldProfile) {
                    const profile = JSON.parse(oldProfile);
                    // Migrate to new format
                    if (!profile.id) {
                        profile.id = generateCharacterId();
                    }
                    saveCharacterProfile(profile, profile.id);
                    // Remove old key
                    localStorage.removeItem('characterProfile');
                    return profile;
                }
            } catch (e) {
                console.error('Failed to migrate old character profile:', e);
            }
            
            return null;
        }

        // Save character profile with ID
        function saveCharacterProfile(profile, id) {
            if (!id) {
                id = generateCharacterId();
            }
            localStorage.setItem(CHARACTER_PROFILE_PREFIX + id, JSON.stringify(profile));
            setActiveCharacterId(id);
            return id;
        }

        // Get all saved character profiles
        function getAllCharacterProfiles() {
            const profiles = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(CHARACTER_PROFILE_PREFIX)) {
                    try {
                        const id = key.replace(CHARACTER_PROFILE_PREFIX, '');
                        const profileData = localStorage.getItem(key);
                        if (profileData) {
                            const profile = JSON.parse(profileData);
                            profile.id = id; // Ensure ID is set
                            profiles.push(profile);
                        }
                    } catch (e) {
                        console.error('Failed to load character profile:', key, e);
                    }
                }
            }
            return profiles.sort((a, b) => {
                // Sort by name, then by creation time
                if (a.name && b.name) {
                    return a.name.localeCompare(b.name);
                }
                return 0;
            });
        }

        // Populate character library dropdown
        function populateCharacterLibrary() {
            const select = document.getElementById('character-library-select');
            if (!select) return;

            const profiles = getAllCharacterProfiles();
            const activeId = getActiveCharacterId();

            // Clear existing options except the first one
            select.innerHTML = '<option value="">(No Character)</option>';

            // Add character options
            profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.id;
                const displayName = profile.name || `Character ${profile.id.substring(0, 8)}`;
                const classLevel = profile.className && profile.level ? ` (${profile.className} ${profile.level})` : '';
                option.textContent = `${displayName}${classLevel}`;
                if (profile.id === activeId) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        // Switch to a different character
        function switchCharacter(characterId) {
            if (!characterId) {
                // Clear active character
                localStorage.removeItem(ACTIVE_CHARACTER_ID_KEY);
                showToast('No character selected');
                updateUI();
                return;
            }

            // Verify character exists
            const profileData = localStorage.getItem(CHARACTER_PROFILE_PREFIX + characterId);
            if (!profileData) {
                showToast('Character not found');
                populateCharacterLibrary();
                return;
            }

            // Set as active
            setActiveCharacterId(characterId);
            
            // Load character settings
            try {
                const profile = JSON.parse(profileData);
                applyCharacterProfileToSettings(profile);
                showToast(`Switched to ${profile.name || 'Character'}`);
            } catch (e) {
                console.error('Failed to load character:', e);
                showToast('Failed to load character');
            }

            updateUI();
        }

        // Create a new empty character
        function createNewCharacter() {
            const newProfile = {
                id: generateCharacterId(),
                name: 'New Character',
                className: '',
                level: 0,
                ac: undefined,
                hpMax: undefined,
                speed: undefined,
                initiativeBonus: undefined,
                spellAttackBonus: undefined,
                spellSaveDC: undefined,
                spellSlots: {},
                cantrips: [],
                spells: []
            };

            saveCharacterProfile(newProfile, newProfile.id);
            applyCharacterProfileToSettings(newProfile);
            populateCharacterLibrary();
            updateUI();
            showToast('New character created');
        }

        // Duplicate current character
        function duplicateCurrentCharacter() {
            const currentProfile = getActiveCharacterProfile();
            if (!currentProfile) {
                showToast('No character to duplicate');
                return;
            }

            // Create a copy with new ID
            const duplicated = JSON.parse(JSON.stringify(currentProfile));
            duplicated.id = generateCharacterId();
            duplicated.name = (currentProfile.name || 'Character') + ' (Copy)';

            saveCharacterProfile(duplicated, duplicated.id);
            applyCharacterProfileToSettings(duplicated);
            populateCharacterLibrary();
            updateUI();
            showToast('Character duplicated');
        }

        // Delete current character
        function deleteCurrentCharacter() {
            const activeId = getActiveCharacterId();
            if (!activeId) {
                showToast('No character to delete');
                return;
            }

            const profile = getActiveCharacterProfile();
            const characterName = profile?.name || 'Character';

            if (!confirm(`Delete "${characterName}"? This cannot be undone.`)) {
                return;
            }

            // Remove from localStorage
            localStorage.removeItem(CHARACTER_PROFILE_PREFIX + activeId);
            localStorage.removeItem(ACTIVE_CHARACTER_ID_KEY);

            // Clear settings
            prefs.classKey = '';
            prefs.canHealingWord = false;
            prefs.canOffhandAttack = false;
            prefs.bonusActionEnabled = false;
            savePrefs();

            // Update UI
            populateCharacterLibrary();
            updateUI();
            showToast('Character deleted');
        }

        // Export current character as JSON
        function exportCharacterJSON() {
            const profile = getActiveCharacterProfile();
            if (!profile) {
                showToast('No character to export');
                return;
            }

            // Create clean export (remove debug fields)
            const exportData = { ...profile };
            delete exportData._debugExtractedText;
            delete exportData._debugFields;

            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Generate filename from character name (sanitized)
            let filename = 'character';
            if (profile.name) {
                filename = profile.name
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }
            a.download = `${filename}.json`;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Character exported');
        }

        // Import character from JSON file
        function handleJsonImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.includes('json') && !file.name.toLowerCase().endsWith('.json')) {
                showToast('Please select a JSON file.');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    
                    // Validate it's a character profile
                    if (typeof imported !== 'object' || (!imported.name && !imported.className)) {
                        showToast('Invalid character file format.');
                        event.target.value = '';
                        return;
                    }

                    // Generate new ID for imported character (don't reuse old ID)
                    if (imported.id) {
                        delete imported.id;
                    }
                    imported.id = generateCharacterId();

                    // Save and set as active
                    saveCharacterProfile(imported, imported.id);
                    applyCharacterProfileToSettings(imported);
                    populateCharacterLibrary();
                    updateUI();
                    
                    showToast(`Character "${imported.name || 'Imported Character'}" imported successfully!`);
                } catch (err) {
                    console.error('JSON import error:', err);
                    showToast('Failed to import JSON: ' + err.message);
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }

        function applyCharacterProfileToSettings(profile) {
            // Apply settings based on profile
            prefs.bonusActionEnabled = true;
            prefs.canHealingWord = profile.spells && profile.spells.some(s => s.toLowerCase().includes('healing word'));
            prefs.trackReaction = true;
            prefs.trackInteraction = true;
            prefs.canOffhandAttack = false; // Default for cleric + shield style
            prefs.spellcasterMode = profile.className && profile.className.toLowerCase().includes('cleric');
            prefs.confirmSpends = !!profile.spellSlots && Object.keys(profile.spellSlots).length > 0;
            prefs.decisionHelperEnabled = true;
            prefs.autoResetOnStartTurn = true;

            // Set class if it matches
            const classSelect = document.getElementById('class-select');
            if (classSelect && profile.className) {
                const classKey = profile.className.toLowerCase();
                const validClasses = ['barbarian', 'bard', 'cleric', 'fighter', 'monk', 'paladin', 'ranger', 'rogue', 'sorcerer', 'warlock', 'wizard'];
                if (validClasses.includes(classKey)) {
                    prefs.classKey = classKey;
                    classSelect.value = classKey;
                    applyClassPresets(classKey);
                }
            }

            // Update UI checkboxes
            const toggleBonusAction = document.getElementById('toggle-bonus-action-enabled');
            const toggleHealing = document.getElementById('toggle-healing-word');
            const toggleOffhand = document.getElementById('toggle-offhand-attack');
            const toggleTrackReaction = document.getElementById('toggle-track-reaction');
            const toggleTrackInteraction = document.getElementById('toggle-track-interaction');
            const toggleSpellcaster = document.getElementById('toggle-spellcaster-mode');
            const toggleConfirmSpends = document.getElementById('toggle-confirm-spends');
            const toggleDecisionHelper = document.getElementById('toggle-decision-helper');
            const toggleAutoReset = document.getElementById('toggle-auto-reset');

            if (toggleBonusAction) toggleBonusAction.checked = prefs.bonusActionEnabled;
            if (toggleHealing) toggleHealing.checked = prefs.canHealingWord;
            if (toggleOffhand) toggleOffhand.checked = prefs.canOffhandAttack;
            if (toggleTrackReaction) toggleTrackReaction.checked = prefs.trackReaction;
            if (toggleTrackInteraction) toggleTrackInteraction.checked = prefs.trackInteraction;
            if (toggleSpellcaster) toggleSpellcaster.checked = prefs.spellcasterMode;
            if (toggleConfirmSpends) toggleConfirmSpends.checked = prefs.confirmSpends;
            if (toggleDecisionHelper) toggleDecisionHelper.checked = prefs.decisionHelperEnabled;
            if (toggleAutoReset) toggleAutoReset.checked = prefs.autoResetOnStartTurn;

            // Save preferences
            savePrefs();

            // Add ID to profile and save
            if (!profile.id) {
                profile.id = generateCharacterId();
            }
            const characterId = saveCharacterProfile(profile, profile.id);
            console.log('Character saved with ID:', characterId);

            // Update UI
            updateUI();
        }

        function showImportConfirmDialog(profile, extractedText) {
            const dialogBody = document.getElementById('import-confirm-dialog-body');
            if (!dialogBody) return;

            // Use stored debug text if available
            if (!extractedText && profile._debugExtractedText) {
                extractedText = profile._debugExtractedText;
            }

            let html = '';

            const addItem = (label, value, emptyText = 'Not found') => {
                html += '<div class="profile-item">';
                html += `<div class="profile-label">${label}</div>`;
                if (value !== undefined && value !== null && value !== '' && 
                    !(Array.isArray(value) && value.length === 0) &&
                    !(typeof value === 'object' && Object.keys(value).length === 0)) {
                    if (Array.isArray(value)) {
                        html += `<div class="profile-value">${value.join(', ') || emptyText}</div>`;
                    } else if (typeof value === 'object') {
                        const entries = Object.entries(value).map(([k, v]) => `Level ${k}: ${v}`).join(', ');
                        html += `<div class="profile-value">${entries || emptyText}</div>`;
                    } else {
                        html += `<div class="profile-value">${value}</div>`;
                    }
                } else {
                    html += `<div class="profile-value empty">${emptyText}</div>`;
                }
                html += '</div>';
            };

            addItem('Name', profile.name);
            addItem('Class & Level', profile.className && profile.level ? `${profile.className} ${profile.level}` : null);
            addItem('AC', profile.ac);
            addItem('Max HP', profile.hpMax);
            addItem('Speed', profile.speed ? `${profile.speed} ft` : null);
            addItem('Initiative Bonus', profile.initiativeBonus !== undefined ? (profile.initiativeBonus >= 0 ? '+' : '') + profile.initiativeBonus : null);
            addItem('Spell Attack Bonus', profile.spellAttackBonus !== undefined ? (profile.spellAttackBonus >= 0 ? '+' : '') + profile.spellAttackBonus : null);
            addItem('Spell Save DC', profile.spellSaveDC);
            addItem('Spell Slots', profile.spellSlots);
            addItem('Cantrips', profile.cantrips);
            addItem('Spells', profile.spells);
            const skillsStr = profile.skills && Object.keys(profile.skills).length > 0
                ? Object.entries(profile.skills).map(([k, v]) => `${k} ${v >= 0 ? '+' : ''}${v}`).join(', ')
                : null;
            addItem('Skills', skillsStr);

            // DEBUG SECTION
            if (extractedText) {
                html += '<div class="profile-item" style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 2px solid var(--border);">';
                html += '<div class="profile-label">üîç Debug Info</div>';
                html += `<div class="profile-value" style="margin-bottom: 0.5rem;">Extracted text length: ${extractedText.length}</div>`;
                html += '<details style="margin-top: 0.5rem;">';
                html += '<summary style="cursor: pointer; color: var(--text-light); font-size: 0.9rem;">Show first 1000 characters</summary>';
                html += '<pre style="margin-top: 0.5rem; padding: 0.75rem; background: var(--background); border: 1px solid var(--border); border-radius: 4px; overflow-x: auto; font-size: 0.85rem; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;">';
                html += escapeHtml(extractedText.substring(0, 1000));
                html += '</pre>';
                html += '</details>';
                html += '</div>';
            }

            dialogBody.innerHTML = html;
            document.getElementById('import-confirm-dialog').classList.add('active');
        }

        // Helper function to escape HTML for safe display
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function closeImportConfirmDialog() {
            document.getElementById('import-confirm-dialog').classList.remove('active');
            pendingCharacterProfile = null;
        }

        function confirmCharacterImport() {
            if (pendingCharacterProfile) {
                applyCharacterProfileToSettings(pendingCharacterProfile);
                closeImportConfirmDialog();
                populateCharacterLibrary(); // Update library dropdown
                showToast('Character imported successfully!');
                showScreen('screen-home');
            }
        }

        async function handlePdfImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.includes('pdf') && !file.name.toLowerCase().endsWith('.pdf')) {
                showToast('Please select a PDF file.');
                event.target.value = ''; // Reset file input
                return;
            }

            try {
                showToast('Parsing PDF...');
                
                // Extract text and fieldMap from PDF
                const { text, fieldMap } = await CharacterSheetImporter.extractPdfData(file);
                
                // DEBUG: Log extracted text info
                console.log('=== PDF EXTRACTION DEBUG ===');
                console.log('Extracted text length:', text.length);
                const fieldCount = Object.keys(fieldMap || {}).length;
                console.log('Number of fields found:', fieldCount);
                console.log('First 1000 characters of text:', text.substring(0, 1000));
                console.log('Sample fields:', Object.fromEntries(
                    Object.entries(fieldMap || {}).slice(0, 10)
                ));
                window.__lastPdfText = text; // Store globally for inspection
                window.__lastPdfFields = fieldMap; // Store fieldMap globally for inspection
                
                // DEBUG: Dump spellName values (spellName0..21)
                const spellRows = [];
                for (let i = 0; i <= 21; i++) {
                    const key = `spellName${i}`;
                    const value = fieldMap[key];
                    spellRows.push([key, value]);
                    console.log(`  ${key}:`, value || '(empty)');
                }
                console.log('SPELL ROWS (spellName0..21) - Full dump above');
                
                // DEBUG: Dump spell/DC/attack related fields
                const spellMetaKeys = Object.keys(fieldMap || {}).filter(k => /spell|save dc|attack|ability save|dc/i.test(k));
                console.log('SPELL META KEYS (count):', spellMetaKeys.length);
                spellMetaKeys.forEach(k => {
                    console.log(`  ${k}:`, fieldMap[k]);
                });
                
                // DEBUG: Fix slot keys log to print real contents
                const slotKeys = Object.keys(fieldMap || {}).filter(k => /slot/i.test(k));
                console.log('SLOT PAIRS (count):', slotKeys.length);
                slotKeys.forEach(k => {
                    console.log(`  ${k}:`, fieldMap[k]);
                });
                
                // Safety check: Too little text and no fields
                if (text.length < 200 && (!fieldMap || fieldCount === 0)) {
                    showToast('No readable text found in this PDF (may be flattened image or blocked worker).');
                    console.warn('PDF extraction returned very little text:', text.length, 'characters and', fieldCount, 'fields');
                    event.target.value = '';
                    return;
                }
                
                // Parse into character profile using fieldMap as source of truth, text as fallback
                const profile = CharacterSheetImporter.parseFromFields(fieldMap || {}, text);
                CharacterSheetImporter.normalizeProfileSpells(profile);
                
                // Safety check: Text/fields found but parsing failed
                const hasCoreFields = profile.name || profile.className || profile.ac !== undefined || 
                                     profile.hpMax !== undefined || profile.speed !== undefined;
                if (!hasCoreFields) {
                    showToast('Text found, but format wasn\'t recognized. Likely text-order issue. Check debug output.');
                    console.warn('Parsing found no core fields. Profile:', profile);
                }
                
                // Store for confirmation (include raw text and fieldMap for debug)
                pendingCharacterProfile = profile;
                pendingCharacterProfile._debugExtractedText = text; // Store for debug display
                pendingCharacterProfile._debugFields = fieldMap; // Store fieldMap for debug display
                
                // Show confirmation dialog
                showImportConfirmDialog(profile, text);
                
            } catch (error) {
                console.error('PDF import error:', error);
                showToast('Failed to import PDF: ' + error.message);
            } finally {
                // Reset file input
                event.target.value = '';
            }
        }

        function applyClassPresets(classKey) {
            const toggleBonusAction = document.getElementById('toggle-bonus-action-enabled');
            const toggleHealing = document.getElementById('toggle-healing-word');
            const toggleOffhand = document.getElementById('toggle-offhand-attack');
            const helperPresetSelect = document.getElementById('helper-preset-select');

            // Auto-sync helper preset with class selection
            // Only sync if the class has a helper preset available
            const classesWithPresets = ['cleric', 'barbarian', 'rogue', 'wizard'];
            if (classesWithPresets.includes(classKey)) {
                prefs.helperPreset = classKey;
                if (helperPresetSelect) helperPresetSelect.value = classKey;
            } else if (classKey === '' || classKey === 'other') {
                // Clear preset if no class or "other" selected
                prefs.helperPreset = 'none';
                if (helperPresetSelect) helperPresetSelect.value = 'none';
            }

            switch (classKey) {
                case 'cleric':
                    // Cleric: Healing Word ON, Bonus Action enabled
                    prefs.canHealingWord = true;
                    prefs.bonusActionEnabled = true;
                    if (toggleHealing) toggleHealing.checked = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'barbarian':
                    // Barbarian: Bonus Action enabled (Rage)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'rogue':
                    // Rogue: Bonus Action enabled (Cunning Action)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'monk':
                    // Monk: Bonus Action enabled (Martial Arts, Flurry, etc.)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'fighter':
                    // Fighter: Bonus Action enabled (Second Wind)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'ranger':
                    // Ranger: Bonus Action enabled (various features)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'paladin':
                    // Paladin: Bonus Action enabled (various features)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'bard':
                    // Bard: Bonus Action enabled (Bardic Inspiration)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'sorcerer':
                case 'warlock':
                case 'wizard':
                    // Spellcasters: Spellcaster mode enabled
                    prefs.spellcasterMode = true;
                    const toggleSpellcaster = document.getElementById('toggle-spellcaster-mode');
                    if (toggleSpellcaster) toggleSpellcaster.checked = true;
                    break;
                default:
                    // Other classes: no auto-presets, user can configure manually
                    break;
            }
            savePrefs();
        }

        // Decision Helper Functions
        const helperPrompts = [
            'Need defense? Consider Dodge.',
            'Enemy trying to flee? Consider Ready or Grapple.',
            'Need to reposition? Disengage first.',
            'Need advantage for an ally? Help.'
        ];

        let currentPromptIndex = 0;

        const CLERIC_DEFENSE_SPELLS = ['Shield of Faith', 'Sanctuary'];

        function getClericDefenseSpellSuggestions(profile) {
            if (!profile) return [];
            const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
            const known = normalized.map(s => s.name);
            return CLERIC_DEFENSE_SPELLS.filter(name =>
                known.some(k => k.trim().toLowerCase() === name.trim().toLowerCase())
            );
        }

        function getHelperPresetChips(preset) {
            const chips = {
                cleric: [
                    { if: 'Ally down?', then: 'Healing Word' },
                    { if: 'Need defense?', then: 'Dodge / Shield of Faith' },
                    { if: 'Enemies grouped?', then: 'AoE spell' }
                ],
                barbarian: [
                    { if: 'Low HP?', then: 'Rage' },
                    { if: 'Need to close?', then: 'Dash' },
                    { if: 'Enemy near?', then: 'Reckless Attack' }
                ],
                rogue: [
                    { if: 'Need advantage?', then: 'Hide' },
                    { if: 'Need to escape?', then: 'Cunning Action: Disengage' },
                    { if: 'Enemy isolated?', then: 'Sneak Attack' }
                ],
                wizard: [
                    { if: 'Allies in danger?', then: 'Shield / Counterspell' },
                    { if: 'Enemies grouped?', then: 'AoE spell' },
                    { if: 'Need info?', then: 'Detect Magic' }
                ]
            };
            return chips[preset] || [];
        }

        function rotateHelperPrompt() {
            if (!prefs.decisionHelperEnabled) return;
            currentPromptIndex = (currentPromptIndex + 1) % helperPrompts.length;
            updateHelperPrompt();
        }

        function updateHelperPrompt() {
            const promptEl = document.getElementById('decision-helper-prompt');
            if (promptEl) {
                promptEl.textContent = helperPrompts[currentPromptIndex];
            }
        }

        function handleHelperChipClick(chipText) {
            showToast('Suggestion: ' + chipText);
        }

        function updateDecisionHelper() {
            const helperBox = document.getElementById('decision-helper-box');
            const chipsContainer = document.getElementById('decision-helper-chips');
            
            if (!helperBox || !chipsContainer) return;

            if (prefs.decisionHelperEnabled) {
                helperBox.style.display = 'block';
                // Rotate prompt each time ACTION screen is opened (show current, then advance for next time)
                updateHelperPrompt();
                currentPromptIndex = (currentPromptIndex + 1) % helperPrompts.length;
                
                // Update chips based on preset
                chipsContainer.innerHTML = '';
                if (prefs.helperPreset && prefs.helperPreset !== 'none') {
                    let chips = getHelperPresetChips(prefs.helperPreset);
                    if (prefs.helperPreset === 'cleric') {
                        const profile = getActiveCharacterProfile();
                        const knownDefense = getClericDefenseSpellSuggestions(profile);
                        chips = chips.map(chip => {
                            if (chip.if === 'Need defense?') {
                                const then = knownDefense.length
                                    ? 'Dodge / ' + knownDefense.join(' / ')
                                    : 'Dodge';
                                return { if: chip.if, then };
                            }
                            return chip;
                        });
                    }
                    chips.forEach(chip => {
                        const chipEl = document.createElement('button');
                        chipEl.className = 'decision-helper-chip';
                        chipEl.textContent = chip.if + ' ‚Üí ' + chip.then;
                        chipEl.onclick = () => handleHelperChipClick(chip.then);
                        chipsContainer.appendChild(chipEl);
                    });
                    chipsContainer.style.display = 'flex';
                } else {
                    chipsContainer.style.display = 'none';
                }
            } else {
                helperBox.style.display = 'none';
            }
        }

        function wirePrefsUI() {
            const classSelect = document.getElementById('class-select');
            const toggleBonusAction = document.getElementById('toggle-bonus-action-enabled');
            const toggleHealing = document.getElementById('toggle-healing-word');
            const toggleOffhand = document.getElementById('toggle-offhand-attack');
            const toggleTrackReaction = document.getElementById('toggle-track-reaction');
            const toggleTrackInteraction = document.getElementById('toggle-track-interaction');
            const toggleExtraAttack = document.getElementById('toggle-extra-attack');
            const toggleSpellcaster = document.getElementById('toggle-spellcaster-mode');
            const toggleConfirmSpends = document.getElementById('toggle-confirm-spends');
            const toggleBigButton = document.getElementById('toggle-big-button-mode');
            const toggleAutoReset = document.getElementById('toggle-auto-reset');
            const toggleDecisionHelper = document.getElementById('toggle-decision-helper');
            const helperPresetSelect = document.getElementById('helper-preset-select');

            if (classSelect) {
                classSelect.addEventListener('change', () => {
                    prefs.classKey = classSelect.value;
                    applyClassPresets(classSelect.value);
                    updateUI();
                });
            }

            if (toggleBonusAction) {
                toggleBonusAction.addEventListener('change', () => {
                    prefs.bonusActionEnabled = !!toggleBonusAction.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleHealing) {
                toggleHealing.addEventListener('change', () => {
                    prefs.canHealingWord = !!toggleHealing.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleOffhand) {
                toggleOffhand.addEventListener('change', () => {
                    prefs.canOffhandAttack = !!toggleOffhand.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleTrackReaction) {
                toggleTrackReaction.addEventListener('change', () => {
                    prefs.trackReaction = !!toggleTrackReaction.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleTrackInteraction) {
                toggleTrackInteraction.addEventListener('change', () => {
                    prefs.trackInteraction = !!toggleTrackInteraction.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleExtraAttack) {
                toggleExtraAttack.addEventListener('change', () => {
                    prefs.extraAttackReminder = !!toggleExtraAttack.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleSpellcaster) {
                toggleSpellcaster.addEventListener('change', () => {
                    prefs.spellcasterMode = !!toggleSpellcaster.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleConfirmSpends) {
                toggleConfirmSpends.addEventListener('change', () => {
                    prefs.confirmSpends = !!toggleConfirmSpends.checked;
                    savePrefs();
                });
            }

            if (toggleBigButton) {
                toggleBigButton.addEventListener('change', () => {
                    prefs.bigButtonMode = !!toggleBigButton.checked;
                    savePrefs();
                    if (prefs.bigButtonMode) {
                        document.body.classList.add('big-button-mode');
                    } else {
                        document.body.classList.remove('big-button-mode');
                    }
                });
            }

            if (toggleAutoReset) {
                toggleAutoReset.addEventListener('change', () => {
                    prefs.autoResetOnStartTurn = !!toggleAutoReset.checked;
                    savePrefs();
                });
            }

            if (toggleDecisionHelper) {
                toggleDecisionHelper.addEventListener('change', () => {
                    prefs.decisionHelperEnabled = !!toggleDecisionHelper.checked;
                    savePrefs();
                    updateDecisionHelper();
                });
            }

            if (helperPresetSelect) {
                helperPresetSelect.addEventListener('change', () => {
                    prefs.helperPreset = helperPresetSelect.value || 'none';
                    savePrefs();
                    updateDecisionHelper();
                });
            }
        }

        // Toggle reaction detail expansion
        function toggleReactionDetail(element) {
            element.classList.toggle('expanded');
        }

        // Toggle collapsible section
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.toggle('expanded');
            }
        }

        // ============================================================================
        // CHARACTER PROFILE HELPERS
        // ============================================================================

        /**
         * Get active character profile from localStorage
         * Returns null if no character is loaded
         */
        function getActiveCharacterProfile() {
            // Check for character profile in localStorage
            // Try multiple possible keys for backward compatibility
            const possibleKeys = [
                'activeCharacterId',
                'characterProfile',
                'characterProfileV1'
            ];
            
            for (const key of possibleKeys) {
                const activeId = localStorage.getItem(key);
                if (activeId) {
                    // Try to get profile by ID
                    const profileKey = `characterProfileV1:${activeId}`;
                    const profileData = localStorage.getItem(profileKey);
                    if (profileData) {
                        try {
                            return JSON.parse(profileData);
                        } catch (e) {
                            console.error('Failed to parse character profile:', e);
                        }
                    }
                }
            }
            
            // Fallback: try direct characterProfile key
            const directProfile = localStorage.getItem('characterProfile');
            if (directProfile) {
                try {
                    return JSON.parse(directProfile);
                } catch (e) {
                    console.error('Failed to parse character profile:', e);
                }
            }
            
            return null;
        }

        // ============================================================================
        // SPELL NORMALIZATION AND FIXES
        // ============================================================================

        function getCantrips(profile) {
            const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
            return normalized.filter(s => s.levelGroup === 'cantrip').map(s => s.name);
        }

        /**
         * Get spells by level from normalized spells
         */
        function getSpellsByLevel(profile, level) {
            const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
            return normalized.filter(s => s.levelGroup === level).map(s => s.name);
        }

        /**
         * Get bonus action spells from normalized spells
         */
        function getBonusActionSpellsFromNormalized(profile) {
            const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
            return normalized.filter(s => s.isBonusAction).map(s => s.name);
        }

        /**
         * Get reaction spells from normalized spells
         */
        function getReactionSpells(profile) {
            const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
            return normalized.filter(s => s.isReaction);
        }

        /**
         * Get spell level for slot consumption
         * Returns 0 for cantrips, or the numeric level for leveled spells
         */
        function getSpellLevelForSlot(spellName, profile) {
            const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
            const spell = normalized.find(s => s.name === spellName);
            if (!spell) return 1; // Default fallback
            return spell.levelGroup === 'cantrip' ? 0 : spell.levelGroup;
        }

        const SPELL_FREE_USES_KEY = 'spellFreeUsesState';

        function loadSpellFreeUsesState() {
            try {
                const raw = localStorage.getItem(SPELL_FREE_USES_KEY);
                return raw ? JSON.parse(raw) : {};
            } catch (e) {
                return {};
            }
        }

        function saveSpellFreeUsesState(obj) {
            localStorage.setItem(SPELL_FREE_USES_KEY, JSON.stringify(obj));
        }

        function getSpellFreeUsesRemaining(characterId, spellName) {
            if (!characterId) return undefined;
            const map = loadSpellFreeUsesState();
            const byChar = map[characterId];
            return byChar && typeof byChar[spellName] === 'number' ? byChar[spellName] : undefined;
        }

        function setSpellFreeUsesRemaining(characterId, spellName, remaining) {
            const map = loadSpellFreeUsesState();
            if (!map[characterId]) map[characterId] = {};
            map[characterId][spellName] = remaining;
            saveSpellFreeUsesState(map);
        }

        /**
         * Get free-cast info for a spell (X/LR or X/SR from spellNotes).
         * Returns { freeUsesMax, freeUsesRemaining, freeUseRestType } or null.
         */
        function getSpellFreeCastInfo(spellName, profile) {
            if (!profile) return null;
            const normalized = CharacterSheetImporter.getNormalizedSpells(profile);
            const spell = normalized.find(s => s.name === spellName);
            if (!spell || !spell.freeUsesMax || !spell.freeUseRestType) return null;
            const characterId = getActiveCharacterId();
            let remaining = getSpellFreeUsesRemaining(characterId, spellName);
            if (remaining === undefined) remaining = spell.freeUsesMax;
            return {
                freeUsesMax: spell.freeUsesMax,
                freeUsesRemaining: remaining,
                freeUseRestType: spell.freeUseRestType
            };
        }

        /**
         * Update reaction section with actual reaction spells from character
         */
        function updateReactionSpells() {
            const container = document.getElementById('spell-reactions-container');
            if (!container) return;

            // Get active character profile
            const profile = getActiveCharacterProfile();
            if (!profile) {
                container.innerHTML = '';
                return;
            }

            const reactionSpells = getReactionSpells(profile);
            
            if (reactionSpells.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '';
            reactionSpells.forEach(spell => {
                const levelText = spell.levelGroup === 'cantrip' ? 'Cantrip' : `Level ${spell.levelGroup}`;
                html += `<div class="reaction-item" onclick="toggleReactionDetail(this)">`;
                html += `<div class="reaction-item-header">`;
                html += `<div class="reaction-item-title">`;
                html += `<span>‚ú®</span>`;
                html += `<strong>${spell.name}</strong>`;
                html += `<span class="reaction-item-subtitle">- ${levelText} (Reaction)</span>`;
                html += `</div>`;
                html += `<span class="reaction-item-expand-icon">‚ñ∂</span>`;
                html += `</div>`;
                html += `<div class="reaction-item-details">`;
                html += `<p><strong>${levelText} spell</strong></p>`;
                if (spell.castingTime) {
                    html += `<p><strong>Casting Time:</strong> ${spell.castingTime}</p>`;
                }
                html += `</div>`;
                html += `</div>`;
            });

            container.innerHTML = html;
        }

        // Auto-detect mobile and enable big buttons by default
        function detectMobile() {
            // Check if user has explicitly set bigButtonMode preference
            const saved = localStorage.getItem(PREFS_KEY);
            if (saved) {
                const savedPrefs = JSON.parse(saved);
                // If user has explicitly set it, don't override
                if (savedPrefs.bigButtonMode !== undefined) {
                    return;
                }
            }
            
            // Detect mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                            (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) ||
                            ('ontouchstart' in window);
            
            if (isMobile && prefs.bigButtonMode === false) {
                prefs.bigButtonMode = true;
                savePrefs();
                // Apply immediately
                if (prefs.bigButtonMode) {
                    document.body.classList.add('big-button-mode');
                }
            }
        }

        // Show help section on first visit
        function initHelpSection() {
            const helpSection = document.getElementById('help-section');
            if (!helpSection) return;
            
            const hasSeenHelp = localStorage.getItem('hasSeenHelp');
            if (!hasSeenHelp) {
                // First visit - show expanded
                helpSection.classList.add('expanded');
                localStorage.setItem('hasSeenHelp', 'true');
            }
        }

        // Initialize
        loadPrefs();
        detectMobile();
        wirePrefsUI();
        loadState();
        updateUI();
        initHelpSection();
    </script>
</body>
</html>
