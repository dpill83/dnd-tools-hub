<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D 5e Combat Turn Helper</title>
    <style>
        :root {
            --primary-color: #1a472a;
            --primary-light: #2d5a3d;
            --secondary-color: #8b4513;
            --accent-color: #d4af37;
            --background: #f5f5f5;
            --surface: #ffffff;
            --text: #333333;
            --text-light: #666666;
            --border: #dddddd;
            --error: #dc3545;
            --warning: #ffc107;
            --success: #28a745;
            --shadow: rgba(0, 0, 0, 0.1);
            --shadow-hover: rgba(0, 0, 0, 0.15);
        }

        /* Dark Mode CSS Variables */
        .dark-mode {
            --primary-color: #4a9b5f;
            --primary-light: #5cb377;
            --secondary-color: #a67c52;
            --accent-color: #f4d03f;
            --background: #1a1a1a;
            --surface: #2d2d2d;
            --text: #e0e0e0;
            --text-light: #b0b0b0;
            --border: #404040;
            --error: #ff6b7a;
            --warning: #ffd54f;
            --success: #66bb6a;
            --shadow: rgba(0, 0, 0, 0.3);
            --shadow-hover: rgba(0, 0, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: var(--text);
            background-color: var(--background);
            padding: 1rem;
            min-height: 100vh;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background-color: var(--surface);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow);
            min-height: calc(100vh - 2rem);
            transition: background-color 0.3s ease;
        }


        /* Reaction Widget (NOT YOUR TURN Screen) */
        .reaction-widget-large {
            background-color: rgba(0, 0, 0, 0.05);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .dark-mode .reaction-widget-large {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .reaction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .reaction-label-large {
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--text);
        }

        .reaction-status-large {
            min-width: 120px;
            text-align: center;
            font-size: 1rem;
            padding: 0.5rem 1rem;
            font-weight: 600;
            border-radius: 4px;
        }

        /* tracker-status classes (only used by reaction widget on NOT YOUR TURN screen) */
        .tracker-status.available {
            background-color: var(--success);
            color: white;
            cursor: pointer;
        }

        .tracker-status.available:hover {
            opacity: 0.8;
        }

        .tracker-status.used {
            background-color: var(--error);
            color: white;
            cursor: pointer;
        }

        .tracker-status.used:hover {
            opacity: 0.8;
        }

        .tracker-status.reserved {
            background-color: var(--warning);
            color: var(--text);
            cursor: not-allowed;
        }

        .reaction-hint {
            font-size: 0.875rem;
            color: var(--text-light);
            margin: 0;
        }

        /* Reactions Reference */
        .reactions-reference {
            background-color: rgba(0, 0, 0, 0.03);
            border-left: 4px solid var(--accent-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .dark-mode .reactions-reference {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .reactions-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .reaction-item {
            font-size: 0.875rem;
            color: var(--text);
            padding: 0.5rem;
            background-color: rgba(0, 0, 0, 0.02);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .reaction-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .dark-mode .reaction-item {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .dark-mode .reaction-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .reaction-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reaction-item-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .reaction-item-subtitle {
            color: var(--text-light);
        }

        .reaction-item-expand-icon {
            font-size: 0.75rem;
            transition: transform 0.2s;
            color: var(--text-light);
        }

        .reaction-item.expanded .reaction-item-expand-icon {
            transform: rotate(90deg);
        }

        .reaction-item-details {
            display: none;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .reaction-item.expanded .reaction-item-details {
            display: block;
        }

        .reaction-item-details p {
            margin-bottom: 0.5rem;
        }

        .reaction-item-details ul {
            margin-left: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .reaction-item-details li {
            margin-bottom: 0.25rem;
        }

        .reaction-page-numbers {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border);
            font-size: 0.8rem;
            color: var(--text-light);
            font-style: italic;
        }

        /* Screen Views */
        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* End Turn Container */
        .end-turn-container {
            background-color: var(--surface);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .headline {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 1.5rem;
        }

        /* End Turn screen specific spacing */
        #screen-end-turn .headline {
            margin-bottom: 1rem;
        }

        .headline.not-your-turn {
            color: var(--text-light);
        }

        /* Button Grid */
        .button-grid {
            display: grid;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        /* Action grid for organizing action buttons */
        .action-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 480px) {
            .action-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Collapsible Section */
        .collapsible-section {
            margin-bottom: 1rem;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background-color: rgba(0, 0, 0, 0.03);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            -webkit-user-select: none;
            user-select: none;
        }

        .dark-mode .collapsible-header {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .collapsible-header:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .dark-mode .collapsible-header:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .collapsible-header-text {
            font-weight: 600;
            color: var(--text);
        }

        .collapsible-icon {
            transition: transform 0.2s;
            color: var(--text-light);
        }

        .collapsible-section.expanded .collapsible-icon {
            transform: rotate(90deg);
        }

        .collapsible-content {
            display: none;
            margin-top: 0.75rem;
        }

        .collapsible-section.expanded .collapsible-content {
            display: block;
        }

        /* Spells Panel */
        .spells-panel {
            margin: 1rem 0;
        }

        .spells-section {
            margin-bottom: 1rem;
        }

        .spells-section-title {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .spells-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .spell-item {
            padding: 0.5rem 0.75rem;
            background-color: rgba(0, 0, 0, 0.02);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--text);
        }

        .dark-mode .spell-item {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .spell-slots-info {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
        }

        .spell-slots-remaining {
            font-weight: 600;
            color: var(--primary-color);
        }

        .spell-slots-empty {
            color: var(--text-light);
            font-style: italic;
        }

        .spell-item {
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .spell-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
            transform: translateX(2px);
        }

        .dark-mode .spell-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .spell-item:active {
            transform: translateX(0);
        }

        /* Spell Selection Screen */
        .spell-selection-content {
            margin: 1rem 0;
        }

        /* Turn Log */
        .turn-log {
            margin: 1rem 0;
            padding: 0.75rem;
            background-color: rgba(0, 0, 0, 0.02);
            border: 1px solid var(--border);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.875rem;
        }

        .dark-mode .turn-log {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .turn-log-header {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .turn-log-clear {
            font-size: 0.75rem;
            color: var(--text-light);
            cursor: pointer;
            text-decoration: underline;
        }

        .turn-log-clear:hover {
            color: var(--text);
        }

        .turn-log-entry {
            padding: 0.25rem 0;
            color: var(--text);
            border-bottom: 1px solid var(--border);
        }

        .turn-log-entry:last-child {
            border-bottom: none;
        }

        .turn-log-entry-time {
            color: var(--text-light);
            font-size: 0.75rem;
            margin-right: 0.5rem;
        }

        .turn-log-empty {
            color: var(--text-light);
            font-style: italic;
            text-align: center;
            padding: 0.5rem 0;
        }

        /* Spell Slot Spending Dialog */
        .spell-slot-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .spell-slot-dialog.active {
            display: flex;
        }

        .spell-slot-dialog-content {
            background-color: var(--surface);
            padding: 1.5rem;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
        }

        .spell-slot-dialog-message {
            margin-bottom: 1rem;
            font-size: 1rem;
            line-height: 1.5;
        }

        .spell-slot-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .collapsible-section.expanded .collapsible-content {
            display: block;
        }

        /* Minor buttons container (Settings and Reset) */
        .minor-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .minor-buttons .btn {
            flex: 1;
        }

        /* End Turn screen - reduce button grid spacing */
        #screen-end-turn .button-grid {
            margin-bottom: 0;
            margin-top: 1rem;
        }

        .btn {
            padding: 1rem 1.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-light);
            box-shadow: 0 4px 8px var(--shadow-hover);
        }

        .btn-primary:active {
            transform: scale(0.98);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-secondary:hover {
            background-color: #6b3410;
            box-shadow: 0 4px 8px var(--shadow-hover);
        }

        .btn-accent {
            background-color: var(--accent-color);
            color: #1a1a1a;
            font-weight: 600;
        }

        .btn-accent:hover {
            background-color: #c19d2e;
            box-shadow: 0 4px 8px var(--shadow-hover);
        }

        .dark-mode .btn-accent {
            color: #1a1a1a;
        }

        .btn-danger {
            background-color: var(--error);
            color: white;
        }

        .btn-danger:hover {
            background-color: #c82333;
            box-shadow: 0 4px 8px var(--shadow-hover);
        }

        .btn-success {
            background-color: var(--success);
            color: white;
        }

        .btn-success:hover {
            background-color: #218838;
            box-shadow: 0 4px 8px var(--shadow-hover);
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            min-height: 44px;
        }

        /* Big Button Mode */
        .big-button-mode .btn {
            min-height: 80px;
            font-size: 1.5rem;
            padding: 1.25rem 2rem;
        }

        .big-button-mode .btn-small {
            min-height: 60px;
            font-size: 1.125rem;
            padding: 0.75rem 1.5rem;
        }

        /* DM Panel */

        /* Detail Content */
        .detail-content {
            margin-bottom: 2rem;
            line-height: 1.8;
        }

        .detail-content p {
            margin-bottom: 1rem;
        }

        .detail-content ul {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .detail-content li {
            margin-bottom: 0.5rem;
        }

        /* D&D Character Sheet Style Speed Display */
        .speed-display {
            margin: 1.5rem auto;
            max-width: 200px;
            border: 2px solid var(--text);
            border-radius: 6px;
            background: var(--surface);
            overflow: hidden;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .speed-display-value {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 1rem;
            text-align: center;
            border-bottom: 2px solid var(--text);
        }

        .speed-display-value .speed-number {
            font-size: 2rem;
            font-weight: bold;
            color: var(--text);
            line-height: 1.2;
        }

        .speed-display-value .speed-unit {
            font-size: 1.25rem;
            color: var(--text);
            margin-left: 0.25rem;
        }

        .speed-display-value .speed-type {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            margin-top: 0.25rem;
            letter-spacing: 0.5px;
        }

        .speed-display-label {
            padding: 0.5rem;
            text-align: center;
            background: var(--surface);
            font-weight: 600;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text);
        }

        .dark-mode .speed-display-value {
            background: linear-gradient(135deg, #1e3a5f 0%, #2d4a6f 100%);
        }

        /* Modal Body (used in attack tree) */
        .modal-body {
            margin-bottom: 1.5rem;
            line-height: 1.8;
        }

        .modal-body p {
            margin-bottom: 0.75rem;
        }

        .modal-body ul {
            margin-left: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .modal-body li {
            margin-bottom: 0.5rem;
        }

        /* Decision Helper Box */
        .decision-helper-box {
            display: none;
            background-color: rgba(0, 0, 0, 0.03);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }

        .dark-mode .decision-helper-box {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .decision-helper-prompt {
            color: var(--text);
            margin-bottom: 0.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .decision-helper-prompt:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .dark-mode .decision-helper-prompt:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .decision-helper-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .decision-helper-chip {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 0.375rem 0.75rem;
            font-size: 0.8rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        .decision-helper-chip:hover {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .decision-helper-chip:active {
            transform: scale(0.95);
        }

        /* Attack Tree */
        .attack-tree {
            display: none;
        }

        .attack-tree.active {
            display: block;
        }

        .attack-step {
            display: none;
        }

        .attack-step.active {
            display: block;
        }

        .help-text {
            font-size: 0.875rem;
            color: var(--text-light);
            font-style: italic;
            margin: 0.5rem 0;
            padding: 0.5rem;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }

        .dark-mode .help-text {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* End Turn Checklist */
        .checklist-screen {
            list-style: none;
            margin-bottom: 1rem;
            padding: 0;
        }

        /* End Turn screen - reduce checklist spacing */
        #screen-end-turn .checklist-screen {
            margin-bottom: 0.5rem;
        }

        .checklist-screen li {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: rgba(0, 0, 0, 0.03);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .dark-mode .checklist-screen li {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .checklist-screen .status {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .status.used {
            background-color: var(--error);
            color: white;
        }

        .status.unused {
            background-color: var(--success);
            color: white;
        }

        .status.available {
            background-color: var(--success);
            color: white;
        }

        .status.reserved {
            background-color: var(--warning);
            color: var(--text);
        }

        /* Navigation */
        .nav-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .nav-buttons .btn {
            flex: 1;
        }


        /* Responsive */
        @media (max-width: 480px) {
            .container {
                padding: 0.75rem;
            }

            .headline {
                font-size: 1.5rem;
            }

            .btn {
                font-size: 1rem;
                padding: 0.875rem 1.25rem;
            }
        }

        /* Dash Active Note */
        .dash-note {
            background-color: rgba(74, 155, 95, 0.1);
            border-left: 4px solid var(--primary-color);
            padding: 0.75rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            font-size: 0.875rem;
            transition: background-color 0.3s ease;
        }

        .dark-mode .dash-note {
            background-color: rgba(74, 155, 95, 0.2);
        }

        /* DM Panel (compact) */
        .dm-panel-compact {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background-color: rgba(212, 175, 55, 0.1);
            border-left: 3px solid var(--accent-color);
            border-radius: 4px;
            font-size: 0.875rem;
            text-align: center;
        }

        .dark-mode .dm-panel-compact {
            background-color: rgba(244, 208, 63, 0.1);
        }

        .dm-panel-compact .dm-label {
            font-weight: 600;
            color: var(--secondary-color);
            margin-bottom: 0.25rem;
        }

        .dark-mode .dm-panel-compact .dm-label {
            color: var(--accent-color);
        }

        .dm-panel-compact .dm-resources {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }

        .dm-panel-compact .dm-resource-item {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            font-size: 0.8rem;
        }

        .dark-mode .dm-panel-compact .dm-resource-item {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Character Setup (compact) */
        .character-setup-compact {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background-color: rgba(0, 0, 0, 0.03);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .dark-mode .character-setup-compact {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .setup-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .setup-row label {
            font-weight: 600;
            color: var(--text);
            white-space: nowrap;
        }

        .setup-row select {
            flex: 1;
            padding: 0.45rem 0.6rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            background-color: var(--surface);
            color: var(--text);
        }

        .setup-toggles {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: center;
        }

        .setup-toggles label {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            color: var(--text);
        }

        .setup-toggles input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--error);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            font-size: 0.9rem;
            font-weight: 500;
            max-width: 90%;
            text-align: center;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Reset Confirm Dialog */
        .reset-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .reset-dialog.active {
            display: flex;
        }

        .reset-dialog-content {
            background-color: var(--surface);
            padding: 1.5rem;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
        }

        .reset-dialog-message {
            margin-bottom: 1.5rem;
            font-size: 1.125rem;
        }

        .reset-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        /* End Turn Safety Net Dialog */
        .end-turn-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .end-turn-dialog.active {
            display: flex;
        }

        .end-turn-dialog-content {
            background-color: var(--surface);
            padding: 1.5rem;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
        }

        .end-turn-dialog-message {
            margin-bottom: 1rem;
            font-size: 1rem;
            line-height: 1.5;
        }

        .end-turn-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .end-turn-dialog-quick-actions {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            display: none;
        }

        .end-turn-dialog-quick-actions.show {
            display: block;
        }


        .end-turn-dialog-quick-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Import Character Confirmation Dialog */
        .import-confirm-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .import-confirm-dialog.active {
            display: flex;
        }

        .import-confirm-dialog-content {
            background-color: var(--surface);
            padding: 1.5rem;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .import-confirm-dialog-header {
            margin-bottom: 1rem;
        }

        .import-confirm-dialog-header h2 {
            margin: 0;
            font-size: 1.25rem;
            color: var(--text);
        }

        .import-confirm-dialog-body {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1.5rem;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .import-confirm-dialog-body .profile-item {
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .import-confirm-dialog-body .profile-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .import-confirm-dialog-body .profile-label {
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.25rem;
        }

        .import-confirm-dialog-body .profile-value {
            color: var(--text-light);
        }

        .import-confirm-dialog-body .profile-value.empty {
            color: var(--text-light);
            font-style: italic;
        }

        .import-confirm-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        /* Default hidden elements (JS will reveal when needed) */
        #dash-note {
            display: none;
        }

        /* Used buttons grid */
        .used-grid {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .btn.used {
            background-color: rgba(0, 0, 0, 0.1);
            opacity: 0.8;
        }

        .dark-mode .btn.used {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .btn.used:hover {
            opacity: 0.9;
        }

        /* Common utility classes (avoid inline styles) */
        .start-turn-grid {
            margin-bottom: 1.5rem;
        }

        .section-title {
            margin-bottom: 0.75rem;
            color: var(--primary-color);
            font-size: 1rem;
        }

        /* Tooltip */
        .help-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: var(--text-light);
            color: var(--surface);
            font-size: 0.75rem;
            font-weight: bold;
            cursor: help;
            margin-left: 0.5rem;
            vertical-align: middle;
            transition: background-color 0.2s;
        }

        .help-icon:hover {
            background-color: var(--primary-color);
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip-content {
            visibility: hidden;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--text);
            color: var(--surface);
            text-align: left;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.875rem;
            white-space: normal;
            width: 250px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 6px;
            border-style: solid;
            border-color: var(--text) transparent transparent transparent;
        }

        .tooltip:hover .tooltip-content,
        .tooltip.active .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        .hint-text {
            text-align: center;
            margin-top: 1.5rem;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .tight-top {
            margin-top: 0.5rem;
        }

        .muted-center {
            text-align: center;
            color: var(--text-light);
            margin: 0;
        }
    </style>
    <!-- PDF.js for PDF text extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        (function() {
            function configureWorker() {
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                } else {
                    // Retry if library not loaded yet
                    setTimeout(configureWorker, 100);
                }
            }
            configureWorker();
        })();
    </script>
</head>
<body>
    <div class="container">
        <!-- Home Screen -->
        <div class="screen active" id="screen-home">
            <!-- Help Section (collapsible, shown on first visit) -->
            <div class="collapsible-section" id="help-section" style="margin-bottom: 1rem;">
                <div class="collapsible-header" onclick="toggleCollapsible('help-section')">
                    <span class="collapsible-header-text">‚ùì What do these mean?</span>
                    <span class="collapsible-icon">‚ñ∂</span>
                </div>
                <div class="collapsible-content">
                    <div style="padding: 0.75rem; background-color: rgba(0, 0, 0, 0.03); border-radius: 4px; font-size: 0.875rem; line-height: 1.6;">
                        <p style="margin-bottom: 0.5rem;"><strong>üèÉ Movement:</strong> Move up to your speed. You can split this before and after your action.</p>
                        <p style="margin-bottom: 0.5rem;"><strong>‚öîÔ∏è Action:</strong> Most common actions are Attack or Cast a Spell. You can also Dash, Dodge, Help, and more.</p>
                        <p style="margin-bottom: 0.5rem;"><strong>‚ú® Bonus Action:</strong> Only if you have a feature that grants one (like Rage, Cunning Action, or a spell).</p>
                        <p style="margin-bottom: 0.5rem;"><strong>ü§è Interaction:</strong> One free object interaction per turn (draw weapon, open door, pick up item).</p>
                        <p style="margin: 0;"><strong>‚ö° Reaction:</strong> Tracked on the "NOT YOUR TURN" screen. You get one per round.</p>
                    </div>
                </div>
            </div>

            <!-- Dash Note -->
            <div class="dash-note" id="dash-note">
                üí® Extra movement granted this turn (Dash active)
            </div>

            <!-- Turn Log -->
            <div class="turn-log" id="turn-log" style="display: none;">
                <div class="turn-log-header">
                    <span>üìã Turn Log</span>
                    <span class="turn-log-clear" onclick="clearTurnLog()">Clear</span>
                </div>
                <div id="turn-log-entries"></div>
            </div>

            <div id="home-available" class="button-grid"></div>
            <div id="home-used" class="button-grid used-grid"></div>
            <div id="home-minor-buttons" class="minor-buttons"></div>
        </div>

        <!-- NOT YOUR TURN Screen -->
        <div class="screen" id="screen-not-your-turn">
            <h1 class="headline not-your-turn">‚è∏Ô∏è NOT YOUR TURN</h1>
            
            <div class="button-grid start-turn-grid">
                <button class="btn btn-primary" onclick="handleStartTurn()">‚ñ∂Ô∏è START TURN</button>
            </div>
            
            <!-- Reaction Widget -->
            <div class="reaction-widget-large" id="reaction-widget-container">
                <div class="reaction-header">
                    <div class="reaction-label-large">‚ö° Reaction</div>
                    <div class="tracker-status reaction-status-large" onclick="toggleReaction()" title="Click to toggle when you use your reaction" id="reaction-widget-status-2">Available</div>
                </div>
                <p class="reaction-hint">Click the status above to mark when you use your reaction</p>
            </div>

            <!-- Common Reactions Reference -->
            <div class="reactions-reference" id="reactions-reference-container">
                <h3 class="section-title">Common Reactions:</h3>
                <div class="reactions-list">
                    <div class="reaction-item" onclick="toggleReactionDetail(this)">
                        <div class="reaction-item-header">
                            <div class="reaction-item-title">
                                <span>‚öîÔ∏è</span>
                                <strong>Opportunity Attack</strong>
                                <span class="reaction-item-subtitle">- When enemy leaves your reach</span>
                            </div>
                            <span class="reaction-item-expand-icon">‚ñ∂</span>
                        </div>
                        <div class="reaction-item-details">
                            <p><strong>You can make an opportunity attack when a hostile creature that you can see moves out of your reach.</strong></p>
                            <p>To make the opportunity attack, you use your reaction to make one melee attack against the provoking creature. The attack occurs right before the creature leaves your reach.</p>
                            <p>You can avoid provoking an opportunity attack by taking the Disengage action. You also don't provoke an opportunity attack when you teleport or when someone or something moves you without using your movement, action, or reaction.</p>
                            <div class="reaction-page-numbers">
                                PHB 2014: p.195 | PHB 2024: [PAGE_PLACEHOLDER]
                            </div>
                        </div>
                    </div>
                    <div class="reaction-item" onclick="toggleReactionDetail(this)">
                        <div class="reaction-item-header">
                            <div class="reaction-item-title">
                                <span>üõ°Ô∏è</span>
                                <strong>Shield</strong>
                                <span class="reaction-item-subtitle">- When hit by an attack (+5 AC)</span>
                            </div>
                            <span class="reaction-item-expand-icon">‚ñ∂</span>
                        </div>
                        <div class="reaction-item-details">
                            <p><strong>1st-level abjuration spell</strong></p>
                            <p><strong>Casting Time:</strong> 1 reaction, which you take when you are hit by an attack or targeted by the magic missile spell</p>
                            <p><strong>Range:</strong> Self</p>
                            <p><strong>Components:</strong> V, S</p>
                            <p><strong>Duration:</strong> 1 round</p>
                            <p>An invisible barrier of magical force appears and protects you. Until the start of your next turn, you have a +5 bonus to AC, including against the triggering attack, and you take no damage from magic missile.</p>
                            <div class="reaction-page-numbers">
                                PHB 2014: p.275 | PHB 2024: [PAGE_PLACEHOLDER]
                            </div>
                        </div>
                    </div>
                    <div class="reaction-item" onclick="toggleReactionDetail(this)">
                        <div class="reaction-item-header">
                            <div class="reaction-item-title">
                                <span>‚ú®</span>
                                <strong>Counterspell</strong>
                                <span class="reaction-item-subtitle">- When enemy casts a spell</span>
                            </div>
                            <span class="reaction-item-expand-icon">‚ñ∂</span>
                        </div>
                        <div class="reaction-item-details">
                            <p><strong>3rd-level abjuration spell</strong></p>
                            <p><strong>Casting Time:</strong> 1 reaction, which you take when you see a creature within 60 feet of you casting a spell</p>
                            <p><strong>Range:</strong> 60 feet</p>
                            <p><strong>Components:</strong> S</p>
                            <p><strong>Duration:</strong> Instantaneous</p>
                            <p>You attempt to interrupt a creature in the process of casting a spell. If the creature is casting a spell of 3rd level or lower, its spell fails and has no effect. If it is casting a spell of 4th level or higher, make an ability check using your spellcasting ability. The DC equals 10 + the spell's level. On a success, the creature's spell fails and has no effect.</p>
                            <p><strong>At Higher Levels:</strong> When you cast this spell using a spell slot of 4th level or higher, the interrupted spell has no effect if its level is less than or equal to the level of the spell slot you used.</p>
                            <div class="reaction-page-numbers">
                                PHB 2014: p.228 | PHB 2024: [PAGE_PLACEHOLDER]
                            </div>
                        </div>
                    </div>
                    <div class="reaction-item" onclick="toggleReactionDetail(this)">
                        <div class="reaction-item-header">
                            <div class="reaction-item-title">
                                <span>‚ö°</span>
                                <strong>Absorb Elements</strong>
                                <span class="reaction-item-subtitle">- When hit by elemental damage</span>
                            </div>
                            <span class="reaction-item-expand-icon">‚ñ∂</span>
                        </div>
                        <div class="reaction-item-details">
                            <p><strong>1st-level abjuration spell</strong></p>
                            <p><strong>Casting Time:</strong> 1 reaction, which you take when you take acid, cold, fire, lightning, or thunder damage</p>
                            <p><strong>Range:</strong> Self</p>
                            <p><strong>Components:</strong> S</p>
                            <p><strong>Duration:</strong> 1 round</p>
                            <p>The spell captures some of the incoming energy, lessening its effect on you and storing it for your next melee attack. You have resistance to the triggering damage type until the start of your next turn. Also, the first time you hit with a melee attack on your next turn, the target takes an extra 1d6 damage of the triggering type, and the spell ends.</p>
                            <p><strong>At Higher Levels:</strong> When you cast this spell using a spell slot of 2nd level or higher, the extra damage increases by 1d6 for each slot level above 1st.</p>
                            <div class="reaction-page-numbers">
                                PHB 2014: [PAGE_PLACEHOLDER] | PHB 2024: [PAGE_PLACEHOLDER]
                            </div>
                        </div>
                    </div>
                    <div class="reaction-item" onclick="toggleReactionDetail(this)">
                        <div class="reaction-item-header">
                            <div class="reaction-item-title">
                                <span>‚è≥</span>
                                <strong>Ready Action</strong>
                                <span class="reaction-item-subtitle">- Use your readied action (if reserved)</span>
                            </div>
                            <span class="reaction-item-expand-icon">‚ñ∂</span>
                        </div>
                        <div class="reaction-item-details">
                            <p><strong>Sometimes you want to get the jump on a foe or wait for a particular circumstance before you act. To do so, you can take the Ready action on your turn, which lets you act using your reaction before the start of your next turn.</strong></p>
                            <p>First, you decide what perceivable circumstance will trigger your reaction. Then, you choose the action you will take in response to that trigger, or you choose to move up to your speed in response to it. Examples include "If the cultist steps on the trapdoor, I'll pull the lever that opens it," and "If the goblin steps next to me, I move away."</p>
                            <p><strong>When the trigger occurs, you can either take your reaction right after the trigger finishes or ignore the trigger. Remember that you can take only one reaction per round.</strong></p>
                            <p>When you ready a spell, you cast it as normal but hold its energy, which you release with your reaction when the trigger occurs. To be readied, a spell must have a casting time of 1 action, and holding onto the spell's magic requires concentration. If your concentration is broken, the spell dissipates without taking effect.</p>
                            <div class="reaction-page-numbers">
                                PHB 2014: p.193 | PHB 2024: [PAGE_PLACEHOLDER]
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <p class="hint-text">
                You can use your reaction during other creatures' turns.
            </p>
        </div>

        <!-- INTERACT Screen -->
        <div class="screen" id="screen-interact">
            <h1 class="headline">ü§è Simple Interaction</h1>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="handleInteract('draw-stow')">üó°Ô∏è Draw/Stow Weapon</button>
                <button class="btn btn-primary" onclick="handleInteract('door')">üö™ Open/Close Door</button>
                <button class="btn btn-primary" onclick="handleInteract('pickup-drop')">üì¶ Pick Up / Drop Item</button>
                <button class="btn btn-primary" onclick="handleInteract('move-object')">ü™ë Move Small Object</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- ACTION Screen -->
        <div class="screen" id="screen-action">
            <h1 class="headline">‚öîÔ∏è Choose Action</h1>
            
            <!-- Decision Helper Box -->
            <div class="decision-helper-box" id="decision-helper-box" style="display:none;">
                <div class="decision-helper-prompt" id="decision-helper-prompt" onclick="rotateHelperPrompt()"></div>
                <div class="decision-helper-chips" id="decision-helper-chips" style="display:none;"></div>
            </div>
            
            <!-- Primary actions (Attack and Cast Spell) -->
            <div class="button-grid">
                <button class="btn btn-accent" onclick="showAttackTree()">‚öîÔ∏è Attack</button>
                <button class="btn btn-primary" onclick="showSpellSelection('action')">‚ú® Cast a Spell</button>
            </div>
            
            <!-- Spellcaster Reminders -->
            <div id="spellcaster-reminders" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background-color: rgba(212, 175, 55, 0.1); border-left: 3px solid var(--accent-color); border-radius: 4px; font-size: 0.875rem;">
                <p style="margin: 0; font-weight: 600; margin-bottom: 0.5rem;">‚ú® Spellcaster Reminders:</p>
                <p style="margin: 0.25rem 0;">üí≠ Concentration?</p>
                <p style="margin: 0.25rem 0;">üìö Spell slots?</p>
            </div>
            
            <!-- Other actions in collapsible section -->
            <div class="collapsible-section" id="other-actions-section">
                <div class="collapsible-header" onclick="toggleCollapsible('other-actions-section')">
                    <span class="collapsible-header-text">üìã Other Actions</span>
                    <span class="collapsible-icon">‚ñ∂</span>
                </div>
                <div class="collapsible-content">
                    <div class="action-grid">
                        <button class="btn btn-primary" onclick="handleDash()">üí® Dash</button>
                        <button class="btn btn-primary" onclick="showActionDetail('search')">üîç Search</button>
                        <button class="btn btn-primary" onclick="showActionDetail('ready')">‚è≥ Ready</button>
                        <button class="btn btn-primary" onclick="showActionDetail('help')">ü§ù Help</button>
                        <button class="btn btn-primary" onclick="showActionDetail('dodge')">üõ°Ô∏è Dodge</button>
                        <button class="btn btn-primary" onclick="showActionDetail('disengage')">üèÉ‚Äç‚ôÇÔ∏è Disengage</button>
                        <button class="btn btn-primary" onclick="showActionDetail('hide')">ü•∑ Hide</button>
                        <button class="btn btn-primary" onclick="showActionDetail('use-object')">üîß Use Object</button>
                        <button class="btn btn-primary" onclick="showActionDetail('shove')">üí™ Shove</button>
                        <button class="btn btn-primary" onclick="showActionDetail('grapple')">ü§º Grapple</button>
                    </div>
                </div>
            </div>
            
            <!-- Interaction (Free) -->
            <div class="button-grid" id="interaction-button-container">
                <button class="btn btn-secondary" onclick="handleInteractClick()">ü§è INTERACT (Free)</button>
            </div>
            
            <!-- Back button -->
            <div class="button-grid">
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- Attack Decision Tree -->
        <div class="screen" id="screen-attack">
            <h1 class="headline">‚öîÔ∏è Attack</h1>
            <div class="attack-tree" id="attack-step-1">
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="attackStep(2, 'weapon')">üó°Ô∏è Weapon Attack</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'spell')">‚ú® Spell Attack</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save')">üé≤ Target Makes a Save</button>
                    <button class="btn btn-secondary" onclick="showScreen('screen-action')">‚Üê Back</button>
                </div>
            </div>

            <!-- Weapon Attack Flow - Simplified: Direct to roll result -->
            <div class="attack-tree" id="attack-weapon">
                <div class="modal-body">
                    <p><strong>Roll d20 + modifier (STR for melee, DEX for ranged/finesse)</strong></p>
                    <div class="help-text">
                        <div>Advantage/Disadvantage?</div>
                        <div>Nat 20 = crit (double dice)</div>
                        <div>Remember Bless/Bane/Guidance/Advantage.</div>
                    </div>
                    <div id="extra-attack-reminder" style="display: none; margin-top: 1rem; padding: 0.75rem; background-color: rgba(0, 0, 0, 0.05); border-radius: 4px;">
                        <p style="margin-bottom: 0.5rem; font-weight: 600;">Extra Attack Reminder:</p>
                        <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <input type="checkbox" style="width: 18px; height: 18px;" />
                            <span>Attack 1</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem;">
                            <input type="checkbox" style="width: 18px; height: 18px;" />
                            <span>Attack 2</span>
                        </label>
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-success" onclick="attackStep(3, 'hit')">‚úÖ Hit</button>
                    <button class="btn btn-danger" onclick="attackStep(3, 'miss')">‚ùå Miss</button>
                    <button class="btn btn-secondary" onclick="attackStep(1)">‚Üê Back</button>
                </div>
            </div>

            <!-- Spell Attack Flow -->
            <div class="attack-tree" id="attack-spell">
                <div class="modal-body">
                    <p><strong>Roll d20 + spellcasting ability modifier + proficiency bonus</strong></p>
                    <div class="help-text">
                        <div>Advantage/Disadvantage?</div>
                        <div>Cover may add +2/+5 AC</div>
                        <div>Nat 20 = crit (double dice)</div>
                        <div>Remember Bless/Bane/Guidance/Advantage.</div>
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-success" onclick="attackStep(3, 'hit')">‚úÖ Hit</button>
                    <button class="btn btn-danger" onclick="attackStep(3, 'miss')">‚ùå Miss</button>
                    <button class="btn btn-secondary" onclick="attackStep(1)">‚Üê Back</button>
                </div>
            </div>

            <!-- Save Flow -->
            <div class="attack-tree" id="attack-save-type">
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-str')">STR</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-dex')">DEX</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-con')">CON</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-int')">INT</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-wis')">WIS</button>
                    <button class="btn btn-primary" onclick="attackStep(2, 'save-cha')">CHA</button>
                    <button class="btn btn-secondary" onclick="attackStep(1)">‚Üê Back</button>
                </div>
            </div>

            <div class="attack-tree" id="attack-save-result">
                <div class="modal-body">
                    <p><strong>DM rolls d20 + target's <span id="save-type-name"></span> modifier vs your spell save DC</strong></p>
                    <p>Spell save DC = 8 + proficiency bonus + spellcasting ability modifier</p>
                </div>
                <div class="button-grid">
                    <button class="btn btn-success" onclick="attackStep(3, 'save-succeeds')">‚úÖ Save Succeeds</button>
                    <button class="btn btn-danger" onclick="attackStep(3, 'save-fails')">‚ùå Save Fails</button>
                    <button class="btn btn-secondary" onclick="attackStep(2, 'save')">‚Üê Back</button>
                </div>
            </div>

            <!-- Hit/Miss Results - Combined into one screen -->
            <div class="attack-tree" id="attack-result">
                <div class="modal-body" id="attack-result-content">
                    <!-- Content will be populated by JavaScript -->
                </div>
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="confirmAttackAction()">‚úÖ Confirm Action</button>
                    <button class="btn btn-secondary" onclick="goBackFromAttackResult()">‚Üê Back</button>
                </div>
            </div>
        </div>

        <!-- BONUS ACTION Screen -->
        <div class="screen" id="screen-bonus-action">
            <h1 class="headline">‚ú® Bonus Action</h1>
            <div class="button-grid" id="bonus-action-options"></div>
            <div class="button-grid tight-top">
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- Spell Selection Screen (for ACTION) -->
        <div class="screen" id="screen-spell-selection-action">
            <h1 class="headline">‚ú® Cast a Spell (Action)</h1>
            <div id="spell-selection-content-action" class="spell-selection-content">
                <!-- Content populated by JavaScript -->
            </div>
            <div class="button-grid">
                <button class="btn btn-secondary" onclick="showScreen('screen-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- Spell Selection Screen (for BONUS ACTION) -->
        <div class="screen" id="screen-spell-selection-bonus">
            <h1 class="headline">‚ú® Cast a Spell (Bonus Action)</h1>
            <div id="spell-selection-content-bonus" class="spell-selection-content">
                <!-- Content populated by JavaScript -->
            </div>
            <div class="button-grid">
                <button class="btn btn-secondary" onclick="showScreen('screen-bonus-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- END TURN Screen -->
        <div class="screen" id="screen-end-turn">
            <div class="end-turn-container">
                <h1 class="headline">‚úÖ End Turn</h1>
                <ul class="checklist-screen">
                    <li>
                        <span>üèÉ Movement</span>
                        <span class="status" id="checklist-movement">Unused</span>
                    </li>
                    <li>
                        <span>‚öîÔ∏è Action</span>
                        <span class="status" id="checklist-action">Unused</span>
                    </li>
                    <li>
                        <span>‚ú® Bonus Action</span>
                        <span class="status" id="checklist-bonus-action">Unused</span>
                    </li>
                    <li id="checklist-interaction-item">
                        <span>ü§è Interaction</span>
                        <span class="status" id="checklist-interaction">Unused</span>
                    </li>
                </ul>
                <!-- Quick actions for unused resources -->
                <div id="end-turn-quick-actions" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background-color: rgba(255, 193, 7, 0.1); border-left: 3px solid var(--warning); border-radius: 4px;">
                    <p style="margin: 0 0 0.5rem 0; font-weight: 600; font-size: 0.875rem;">You still have unused resources:</p>
                    <div id="end-turn-quick-buttons" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-danger" onclick="confirmEndTurn()">‚úÖ Confirm End Turn</button>
                    <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
                </div>
            </div>
        </div>

        <!-- MOVE Detail Screen -->
        <div class="screen" id="screen-move-detail">
            <h1 class="headline">üèÉ Move</h1>
            <div class="detail-content">
                <!-- Speed Display (D&D Character Sheet Style) -->
                <div class="speed-display" id="move-speed-display" style="display: none;">
                    <div class="speed-display-value">
                        <div>
                            <span class="speed-number" id="move-speed-number">30</span>
                            <span class="speed-unit">ft.</span>
                        </div>
                        <div class="speed-type" id="move-speed-type">Walking</div>
                    </div>
                    <div class="speed-display-label">SPEED</div>
                </div>
                
                <p><strong>Move up to your speed, before or after your action.</strong></p>
                <p id="move-description-text">On your turn, you can move a distance up to your speed. You can use some of your movement before and after your action. For example, if you have a speed of 30 feet, you can move 10 feet, take your action, and then move 20 feet more.</p>
            </div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmMove()">‚úÖ Confirm Move</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- DASH Detail Screen -->
        <div class="screen" id="screen-dash-detail">
            <h1 class="headline">üí® Dash</h1>
            <div class="detail-content">
                <p><strong>Dash: move up to your speed again (uses Action)</strong></p>
                <p>When you take the Dash action, you gain extra movement for the current turn. The increase equals your speed, after applying any modifiers. With a speed of 30 feet, for example, you can move up to 60 feet on your turn if you dash.</p>
                <p>Any increase or decrease to your speed changes this additional movement by the same amount. If your speed of 30 feet is reduced to 15 feet, for instance, you can move up to 30 feet this turn if you dash.</p>
            </div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmDash()">‚úÖ Confirm Dash</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- INTERACT Detail Screens -->
        <div class="screen" id="screen-interact-detail">
            <h1 class="headline" id="interact-detail-title">ü§è Simple Interaction</h1>
            <div class="detail-content" id="interact-detail-content"></div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmInteract()">‚úÖ Confirm Interaction</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-interact')">‚Üê Back</button>
            </div>
        </div>

        <!-- ACTION Detail Screens -->
        <div class="screen" id="screen-action-detail">
            <h1 class="headline" id="action-detail-title">‚öîÔ∏è Action</h1>
            <div class="detail-content" id="action-detail-content"></div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmActionDetail()">‚úÖ Confirm Action</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- BONUS ACTION Detail Screens -->
        <div class="screen" id="screen-bonus-action-detail">
            <h1 class="headline" id="bonus-action-detail-title">‚ú® Bonus Action</h1>
            <div class="detail-content" id="bonus-action-detail-content"></div>
            <div class="button-grid">
                <button class="btn btn-primary" onclick="confirmBonusAction()">‚úÖ Confirm Bonus Action</button>
                <button class="btn btn-secondary" onclick="showScreen('screen-bonus-action')">‚Üê Back</button>
            </div>
        </div>

        <!-- SETTINGS Screen -->
        <div class="screen" id="screen-settings">
            <h1 class="headline">‚öôÔ∏è Settings</h1>
            
            <!-- Character Library -->
            <div class="character-setup-compact" style="margin-bottom: 1rem;">
                <div class="setup-row">
                    <label for="character-library-select">üìö Active Character</label>
                    <select id="character-library-select" onchange="switchCharacter(this.value)">
                        <option value="">(No Character)</option>
                    </select>
                </div>
                <div class="button-grid" style="margin-top: 0.75rem;">
                    <button class="btn btn-secondary btn-small" onclick="createNewCharacter()">‚ûï New</button>
                    <button class="btn btn-secondary btn-small" onclick="document.getElementById('import-pdf-file').click()">üìÑ Import PDF</button>
                    <button class="btn btn-secondary btn-small" onclick="document.getElementById('import-json-file').click()">üì• Import JSON</button>
                    <button class="btn btn-secondary btn-small" onclick="exportCharacterJSON()">üíæ Export JSON</button>
                    <button class="btn btn-secondary btn-small" onclick="duplicateCurrentCharacter()">üìã Duplicate</button>
                    <button class="btn btn-secondary btn-small" onclick="deleteCurrentCharacter()">üóëÔ∏è Delete</button>
                </div>
                <input type="file" id="import-pdf-file" accept=".pdf" style="display:none;" onchange="handlePdfImport(event)">
                <input type="file" id="import-json-file" accept=".json" style="display:none;" onchange="handleJsonImport(event)">
            </div>
            
            <!-- Character Setup -->
            <div class="character-setup-compact">
                <div class="setup-row">
                    <label for="class-select">‚öôÔ∏è Class</label>
                    <select id="class-select">
                        <option value="">(Select)</option>
                        <option value="barbarian">Barbarian</option>
                        <option value="bard">Bard</option>
                        <option value="cleric">Cleric</option>
                        <option value="fighter">Fighter</option>
                        <option value="monk">Monk</option>
                        <option value="paladin">Paladin</option>
                        <option value="ranger">Ranger</option>
                        <option value="rogue">Rogue</option>
                        <option value="sorcerer">Sorcerer</option>
                        <option value="warlock">Warlock</option>
                        <option value="wizard">Wizard</option>
                        <option value="other">Other / None</option>
                    </select>
                </div>
                <div class="setup-toggles">
                    <label title="Enable Bonus Action button on Home screen">
                        <input type="checkbox" id="toggle-bonus-action-enabled" />
                        ‚ú® Bonus Action
                    </label>
                    <label title="Show Healing Word option">
                        <input type="checkbox" id="toggle-healing-word" />
                        üíö Healing Word
                    </label>
                    <label title="Show offhand attack option">
                        <input type="checkbox" id="toggle-offhand-attack" />
                        üó°Ô∏è Offhand
                    </label>
                </div>
            </div>


            <!-- Must-Have Settings -->
            <div class="character-setup-compact" style="margin-top: 1rem;">
                <h3 class="section-title" style="margin-bottom: 0.5rem;">Must-Have</h3>
                <div class="setup-toggles">
                    <label title="Track reaction on NOT YOUR TURN screen">
                        <input type="checkbox" id="toggle-track-reaction" />
                        ‚ö° Track Reaction
                    </label>
                    <label title="Track free interaction (draw weapon, open door, etc.)">
                        <input type="checkbox" id="toggle-track-interaction" />
                        ü§è Track Interaction
                    </label>
                </div>
            </div>

            <!-- Useful but Optional Settings (Collapsible) -->
            <div class="collapsible-section" id="useful-settings-section" style="margin-top: 1rem;">
                <div class="collapsible-header" onclick="toggleCollapsible('useful-settings-section')">
                    <span class="collapsible-header-text">‚öôÔ∏è Advanced Settings</span>
                    <span class="collapsible-icon">‚ñ∂</span>
                </div>
                <div class="collapsible-content">
                    <div class="character-setup-compact">
                        <div class="setup-toggles">
                            <label title="Show Extra Attack reminder in attack flow">
                                <input type="checkbox" id="toggle-extra-attack" />
                                ‚öîÔ∏è Extra Attack Reminder
                            </label>
                            <label title="Show spellcaster reminders (concentration, spell slots)">
                                <input type="checkbox" id="toggle-spellcaster-mode" />
                                ‚ú® Spellcaster Mode
                            </label>
                            <label title="Show confirmation dialogs before spending resources">
                                <input type="checkbox" id="toggle-confirm-spends" />
                                ‚úì Confirm Spends
                            </label>
                            <label title="Show decision helper prompts on ACTION screen">
                                <input type="checkbox" id="toggle-decision-helper" />
                                üí° Decision Helper
                            </label>
                        </div>
                        <div class="setup-row" style="margin-top: 0.75rem;">
                            <label for="helper-preset-select">Helper Preset</label>
                            <select id="helper-preset-select">
                                <option value="none">None</option>
                                <option value="cleric">Cleric</option>
                                <option value="barbarian">Barbarian</option>
                                <option value="rogue">Rogue</option>
                                <option value="wizard">Wizard</option>
                            </select>
                        </div>
                        <div class="setup-toggles" style="margin-top: 0.75rem;">
                            <label title="Make buttons larger for phone-at-the-table use">
                                <input type="checkbox" id="toggle-big-button-mode" />
                                üì± Big Button Mode
                            </label>
                            <label title="Automatically reset resources when starting turn">
                                <input type="checkbox" id="toggle-auto-reset" />
                                üîÑ Auto-Reset on Start Turn
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="button-grid">
                <button class="btn btn-secondary" onclick="showScreen('screen-home')">‚Üê Back</button>
            </div>
        </div>

        <!-- Toast Notification -->
        <div class="toast" id="toast"></div>

        <!-- Reset Dialog -->
        <div class="reset-dialog" id="reset-dialog">
            <div class="reset-dialog-content">
                <div class="reset-dialog-message">
                    Reset all turn state? This will clear your current progress.
                </div>
                <div class="reset-dialog-actions">
                    <button class="btn btn-secondary btn-small" onclick="closeResetDialog()">Cancel</button>
                    <button class="btn btn-danger btn-small" onclick="confirmReset()">Reset All</button>
                </div>
            </div>
        </div>

        <!-- End Turn Safety Net Dialog -->
        <div class="end-turn-dialog" id="end-turn-dialog">
            <div class="end-turn-dialog-content">
                <div class="end-turn-dialog-message" id="end-turn-dialog-message">
                    <!-- Message will be populated by JavaScript -->
                </div>
                <div class="end-turn-dialog-quick-actions" id="end-turn-dialog-quick-actions">
                    <div class="end-turn-dialog-quick-buttons" id="end-turn-dialog-quick-buttons">
                        <!-- Quick action buttons will be populated by JavaScript -->
                    </div>
                </div>
                <div class="end-turn-dialog-actions">
                    <button class="btn btn-secondary btn-small" onclick="closeEndTurnDialog()">Go Back</button>
                    <button class="btn btn-danger btn-small" onclick="confirmEndTurnAnyway()">End Turn</button>
                </div>
            </div>
        </div>

        <!-- Import Character Confirmation Dialog -->
        <div class="import-confirm-dialog" id="import-confirm-dialog">
            <div class="import-confirm-dialog-content">
                <div class="import-confirm-dialog-header">
                    <h2>Confirm Character Import</h2>
                </div>
                <div class="import-confirm-dialog-body" id="import-confirm-dialog-body">
                    <!-- Content will be populated by JavaScript -->
                </div>
                <div class="import-confirm-dialog-actions">
                    <button class="btn btn-secondary btn-small" onclick="closeImportConfirmDialog()">Cancel</button>
                    <button class="btn btn-primary btn-small" onclick="confirmCharacterImport()">Confirm</button>
                </div>
            </div>
        </div>

        <!-- Spell Slot Spending Dialog -->
        <div class="spell-slot-dialog" id="spell-slot-dialog">
            <div class="spell-slot-dialog-content">
                <div class="spell-slot-dialog-message" id="spell-slot-dialog-message">
                    <!-- Message will be populated by JavaScript -->
                </div>
                <div class="spell-slot-dialog-actions">
                    <button class="btn btn-secondary btn-small" onclick="cancelSpellSlotSpend()">No</button>
                    <button class="btn btn-primary btn-small" onclick="confirmSpellSlotSpend()">Yes</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State Management
        let state = {
            movement: 'available',
            action: 'available',
            bonusAction: 'available',
            interaction: 'available',
            reaction: 'available',
            dashActive: false,
            actionUsedBy: null,
            currentAttackStep: 1,
            currentSaveType: null,
            pendingAction: null,
            lastAttackType: null,  // Track last attack type for back button
            spellSlotsUsed: {},  // Track used spell slots: {1: 2, 2: 0, ...}
            turnLog: []  // Track spell casts and actions: [{timestamp, action, spell?, level?}]
        };

        // Preferences (class + available options)
        const PREFS_KEY = 'combatTurnPrefs';
        let prefs = {
            classKey: '',
            canHealingWord: false,
            canOffhandAttack: false,
            bonusActionEnabled: false,
            // Must-have settings
            trackReaction: true,
            trackInteraction: true,
            // Useful but optional settings
            extraAttackReminder: false,
            spellcasterMode: false,
            confirmSpends: false,
            decisionHelperEnabled: false,
            helperPreset: 'none',
            // Quality-of-life settings
            bigButtonMode: false,
            autoResetOnStartTurn: false
        };

        // Load state from localStorage
        function loadState() {
            const saved = localStorage.getItem('combatTurnState');
            if (saved) {
                state = { ...state, ...JSON.parse(saved) };
                // Backward compatibility: ensure actionUsedBy defaults to null
                if (state.actionUsedBy === undefined) {
                    state.actionUsedBy = null;
                }
                // Backward compatibility: ensure spellSlotsUsed exists
                if (state.spellSlotsUsed === undefined) {
                    state.spellSlotsUsed = {};
                }
                // Backward compatibility: ensure turnLog exists
                if (state.turnLog === undefined) {
                    state.turnLog = [];
                }
            }
            updateUI();
        }

        function loadPrefs() {
            const saved = localStorage.getItem(PREFS_KEY);
            if (saved) {
                prefs = { ...prefs, ...JSON.parse(saved) };
            }
            // Backward compatibility: ensure defaults for all settings
            if (prefs.bonusActionEnabled === undefined) {
                prefs.bonusActionEnabled = false;
            }
            if (prefs.trackReaction === undefined) {
                prefs.trackReaction = true;
            }
            if (prefs.trackInteraction === undefined) {
                prefs.trackInteraction = true;
            }
            if (prefs.extraAttackReminder === undefined) {
                prefs.extraAttackReminder = false;
            }
            if (prefs.spellcasterMode === undefined) {
                prefs.spellcasterMode = false;
            }
            if (prefs.confirmSpends === undefined) {
                prefs.confirmSpends = false;
            }
            if (prefs.bigButtonMode === undefined) {
                prefs.bigButtonMode = false;
            }
            if (prefs.autoResetOnStartTurn === undefined) {
                prefs.autoResetOnStartTurn = false;
            }
            if (prefs.decisionHelperEnabled === undefined) {
                prefs.decisionHelperEnabled = false;
            }
            if (prefs.helperPreset === undefined) {
                prefs.helperPreset = 'none';
            }

            const classSelect = document.getElementById('class-select');
            const toggleBonusAction = document.getElementById('toggle-bonus-action-enabled');
            const toggleHealing = document.getElementById('toggle-healing-word');
            const toggleOffhand = document.getElementById('toggle-offhand-attack');
            const toggleTrackReaction = document.getElementById('toggle-track-reaction');
            const toggleTrackInteraction = document.getElementById('toggle-track-interaction');
            const toggleExtraAttack = document.getElementById('toggle-extra-attack');
            const toggleSpellcaster = document.getElementById('toggle-spellcaster-mode');
            const toggleConfirmSpends = document.getElementById('toggle-confirm-spends');
            const toggleBigButton = document.getElementById('toggle-big-button-mode');
            const toggleAutoReset = document.getElementById('toggle-auto-reset');
            const toggleDecisionHelper = document.getElementById('toggle-decision-helper');
            const helperPresetSelect = document.getElementById('helper-preset-select');

            if (classSelect) classSelect.value = prefs.classKey || '';
            if (toggleBonusAction) toggleBonusAction.checked = !!prefs.bonusActionEnabled;
            if (toggleHealing) toggleHealing.checked = !!prefs.canHealingWord;
            if (toggleOffhand) toggleOffhand.checked = !!prefs.canOffhandAttack;
            if (toggleTrackReaction) toggleTrackReaction.checked = !!prefs.trackReaction;
            if (toggleTrackInteraction) toggleTrackInteraction.checked = !!prefs.trackInteraction;
            if (toggleExtraAttack) toggleExtraAttack.checked = !!prefs.extraAttackReminder;
            if (toggleSpellcaster) toggleSpellcaster.checked = !!prefs.spellcasterMode;
            if (toggleConfirmSpends) toggleConfirmSpends.checked = !!prefs.confirmSpends;
            if (toggleBigButton) toggleBigButton.checked = !!prefs.bigButtonMode;
            if (toggleAutoReset) toggleAutoReset.checked = !!prefs.autoResetOnStartTurn;
            if (toggleDecisionHelper) toggleDecisionHelper.checked = !!prefs.decisionHelperEnabled;
            if (helperPresetSelect) helperPresetSelect.value = prefs.helperPreset || 'none';

            // Apply big button mode CSS class if enabled
            if (prefs.bigButtonMode) {
                document.body.classList.add('big-button-mode');
            } else {
                document.body.classList.remove('big-button-mode');
            }
        }

        function savePrefs() {
            localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
        }

        function getClassFeatureBonusAction() {
            switch (prefs.classKey) {
                case 'barbarian':
                    return {
                        title: 'üò§ Rage (Barbarian)',
                        content: '<p><strong>Enter a rage as a bonus action.</strong></p><ul><li>Advantage on STR checks/saves</li><li>Bonus damage (varies by level)</li><li>Resistance to bludgeoning/piercing/slashing (while raging)</li></ul><p>Ends early if you end your turn without attacking or taking damage (PHB rules).</p>'
                    };
                case 'bard':
                    return {
                        title: 'üé∂ Bardic Inspiration (Bard)',
                        content: '<p><strong>Give an inspiration die to a creature within 60 ft who can hear you.</strong></p><ul><li>They can add it to an ability check / attack roll / saving throw (timing varies by feature)</li><li>Die size scales with level</li></ul>'
                    };
                case 'fighter':
                    return {
                        title: 'üí™ Second Wind (Fighter)',
                        content: '<p><strong>Regain hit points as a bonus action.</strong></p><ul><li>Heal 1d10 + fighter level</li><li>Once per short/long rest</li></ul>'
                    };
                case 'monk':
                    return {
                        title: 'ü•ã Monk Bonus Action',
                        content: '<p><strong>Common monk bonus actions:</strong></p><ul><li><strong>Martial Arts:</strong> unarmed strike after Attack action</li><li><strong>Flurry of Blows:</strong> spend 1 ki for 2 strikes</li><li><strong>Step of the Wind:</strong> spend 1 ki to Dash/Disengage + jump</li><li><strong>Patient Defense:</strong> spend 1 ki to Dodge</li></ul>'
                    };
                case 'rogue':
                    return {
                        title: 'üó°Ô∏è Cunning Action (Rogue)',
                        content: '<p><strong>Take Dash, Disengage, or Hide as a bonus action.</strong></p><ul><li>Dash: extra movement</li><li>Disengage: avoid opportunity attacks</li><li>Hide: attempt to hide (DM rules)</li></ul>'
                    };
                default:
                    return null;
            }
        }

        function getBonusActionOptions() {
            const options = [];
            if (prefs.canHealingWord) options.push({ key: 'healing-word', label: 'üíö Healing Word' });
            const classFeature = getClassFeatureBonusAction();
            if (classFeature) options.push({ key: 'class-feature', label: classFeature.title });
            if (prefs.canOffhandAttack) options.push({ key: 'offhand-attack', label: 'üó°Ô∏è Offhand Attack' });
            return options;
        }

        function hasBonusActionOptions() {
            // Bonus Action must be enabled in settings AND have at least one option
            return prefs.bonusActionEnabled && getBonusActionOptions().length > 0;
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('combatTurnState', JSON.stringify(state));
        }

        // Update UI based on state
        function updateUI() {
            // Update reaction widget (on NOT YOUR TURN screen)
            updateReactionWidget();

            // Update home buttons
            updateHomeButtons();

            // Update turn log
            updateTurnLog();

            // Update dash note
            document.getElementById('dash-note').style.display = state.dashActive ? 'block' : 'none';

            // Show/hide interaction button in ACTION screen based on setting
            const interactionButtonContainer = document.getElementById('interaction-button-container');
            if (interactionButtonContainer) {
                interactionButtonContainer.style.display = prefs.trackInteraction ? 'block' : 'none';
            }

            // Show/hide spellcaster reminders based on setting
            const spellcasterReminders = document.getElementById('spellcaster-reminders');
            if (spellcasterReminders) {
                spellcasterReminders.style.display = prefs.spellcasterMode ? 'block' : 'none';
            }

            saveState();
        }

        // Count available resources (for End Turn safety net)
        function countAvailableResources() {
            let count = 0;
            const available = [];
            
            if (state.movement === 'available') {
                count++;
                available.push('Movement');
            }
            // Only count Bonus Action if enabled
            if (prefs.bonusActionEnabled && state.bonusAction === 'available' && hasBonusActionOptions()) {
                count++;
                available.push('Bonus Action');
            }
            // Only count Interaction if tracking is enabled
            if (prefs.trackInteraction && state.interaction === 'available') {
                count++;
                available.push('Interaction');
            }
            // Do NOT count Reaction - it's normal to have it available
            
            return { count, available };
        }

        function updateReactionWidget() {
            const status = state.reaction;
            const statusText = status.charAt(0).toUpperCase() + status.slice(1);
            const statusClass = 'tracker-status reaction-status-large ' + status;
            
            // Update reaction widget on NOT YOUR TURN screen
            const widget = document.getElementById('reaction-widget-status-2');
            if (widget) {
                widget.textContent = statusText;
                widget.className = statusClass;
            }
            
            // Show/hide reaction widget and reference based on setting
            const widgetContainer = document.getElementById('reaction-widget-container');
            const referenceContainer = document.getElementById('reactions-reference-container');
            if (widgetContainer) {
                widgetContainer.style.display = prefs.trackReaction ? 'block' : 'none';
            }
            if (referenceContainer) {
                referenceContainer.style.display = prefs.trackReaction ? 'block' : 'none';
            }
        }

        // Update home buttons - dynamically create and place in available/used sections
        function updateHomeButtons() {
            const availableContainer = document.getElementById('home-available');
            const usedContainer = document.getElementById('home-used');
            
            if (!availableContainer || !usedContainer) return;
            
            // Clear both containers
            availableContainer.innerHTML = '';
            usedContainer.innerHTML = '';
            
            // MOVE button (with speed if available)
            let moveLabel = 'üèÉ MOVE';
            let moveLabelUsed = '‚úÖ üèÉ MOVE';
            
            // Try to get speed from active character profile
            try {
                const profile = getActiveCharacterProfile();
                if (profile && profile.speed !== undefined && profile.speed !== null) {
                    moveLabel = `üèÉ MOVE (${profile.speed} ft)`;
                    moveLabelUsed = `‚úÖ üèÉ MOVE (${profile.speed} ft)`;
                }
            } catch (e) {
                // Ignore errors, use default label
            }
            
            if (state.movement === 'available') {
                const btn = createButton(moveLabel, 'btn-primary', () => handleMove());
                availableContainer.appendChild(btn);
            } else {
                const btn = createButton(moveLabelUsed, 'btn-primary used', () => handleUndoMove());
                usedContainer.appendChild(btn);
            }
            
            // ACTION button
            if (state.action === 'available') {
                const btn = createButton('‚öîÔ∏è ACTION', 'btn-primary', () => handleActionClick());
                availableContainer.appendChild(btn);
            } else if (state.action === 'used') {
                // If action was used for Dash, show DASH in used section
                if (state.actionUsedBy === 'dash') {
                    const btn = createButton('‚úÖ üí® DASH (Action)', 'btn-primary used', () => handleUndoDash());
                    usedContainer.appendChild(btn);
                } else {
                    const btn = createButton('‚úÖ ‚öîÔ∏è ACTION', 'btn-primary used', () => handleUndoAction());
                    usedContainer.appendChild(btn);
                }
            }
            
            // BONUS ACTION button (only if options available)
            if (state.bonusAction === 'available' && hasBonusActionOptions()) {
                const btn = createButton('‚ú® BONUS ACTION', 'btn-primary', () => handleBonusActionClick());
                availableContainer.appendChild(btn);
            } else if (state.bonusAction === 'used' && hasBonusActionOptions()) {
                const btn = createButton('‚úÖ ‚ú® BONUS ACTION', 'btn-primary used', () => handleUndoBonusAction());
                usedContainer.appendChild(btn);
            }
            
            // END TURN button (always in available) - dynamic label based on available resources
            const resources = countAvailableResources();
            const endTurnLabel = resources.count > 0 
                ? `‚úÖ END TURN (${resources.count} LEFT)` 
                : '‚úÖ END TURN';
            const endTurnBtn = createButton(endTurnLabel, 'btn-danger', () => handleEndTurn());
            availableContainer.appendChild(endTurnBtn);
            
            // Minor buttons container (Settings and Reset)
            const minorContainer = document.getElementById('home-minor-buttons');
            if (minorContainer) {
                minorContainer.innerHTML = '';
                const settingsBtn = createButton('‚öôÔ∏è Settings', 'btn-secondary', () => showScreen('screen-settings'));
                const resetBtn = createButton('üîÑ Reset All', 'btn-secondary', () => showResetDialog());
                minorContainer.appendChild(settingsBtn);
                minorContainer.appendChild(resetBtn);
            }
        }
        
        // Helper to create button element
        function createButton(text, className, onClick) {
            const btn = document.createElement('button');
            btn.className = `btn ${className}`;
            btn.textContent = text;
            btn.onclick = onClick;
            return btn;
        }


        // Screen Navigation
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            
            // Update decision helper when ACTION screen is shown
            if (screenId === 'screen-action') {
                updateDecisionHelper();
            }
            
            // Update speed display when MOVE screen is shown
            if (screenId === 'screen-move-detail') {
                updateMoveSpeedDisplay();
            }
            
            // Populate character library when SETTINGS screen is shown
            if (screenId === 'screen-settings') {
                populateCharacterLibrary();
            }
        }

        // Known bonus action spells (fallback if metadata not available)
        const BONUS_ACTION_SPELLS = [
            'Healing Word',
            'Sanctuary',
            'Shield of Faith',
            'Hunter\'s Mark',
            'Hex',
            'Misty Step',
            'Spiritual Weapon'
        ];

        // Check if a spell is a bonus action spell
        function isBonusActionSpell(spellName, profile) {
            // First check if we have casting time metadata in rawFields
            if (profile && profile.rawFields) {
                // Look for spellCastingTime fields
                const spellIndex = profile.spells ? profile.spells.indexOf(spellName) : -1;
                if (spellIndex >= 0) {
                    const castingTimeKey = `spellCastingTime${spellIndex}`;
                    const castingTime = profile.rawFields[castingTimeKey];
                    if (castingTime) {
                        const timeStr = String(castingTime).trim().toUpperCase();
                        // Check for "1BA" or "1 Bonus Action" patterns
                        if (timeStr.includes('1BA') || timeStr.includes('BONUS ACTION')) {
                            return true;
                        }
                    }
                }
            }
            
            // Fallback: check against known bonus action spells
            return BONUS_ACTION_SPELLS.some(baSpell => 
                spellName.toLowerCase().includes(baSpell.toLowerCase()) ||
                baSpell.toLowerCase().includes(spellName.toLowerCase())
            );
        }

        // Get bonus action spells from profile
        function getBonusActionSpells(profile) {
            if (!profile || !profile.spells) return [];
            return profile.spells.filter(spell => isBonusActionSpell(spell, profile));
        }

        // Get action spells from profile (all spells except bonus action spells)
        function getActionSpells(profile) {
            if (!profile || !profile.spells) return [];
            const bonusActionSpells = getBonusActionSpells(profile);
            return profile.spells.filter(spell => !bonusActionSpells.includes(spell));
        }

        // Show spell selection screen
        function showSpellSelection(actionType) {
            const profile = getActiveCharacterProfile();
            if (!profile) {
                showToast('No character loaded');
                return;
            }

            const screenId = actionType === 'bonus' ? 'screen-spell-selection-bonus' : 'screen-spell-selection-action';
            const contentId = actionType === 'bonus' ? 'spell-selection-content-bonus' : 'spell-selection-content-action';
            const content = document.getElementById(contentId);
            
            if (!content) return;

            let html = '';
            const hasCantrips = profile.cantrips && profile.cantrips.length > 0;
            const hasSpellSlots = profile.spellSlots && Object.keys(profile.spellSlots).length > 0;

            if (actionType === 'bonus') {
                // Show only bonus action spells
                const bonusSpells = getBonusActionSpells(profile);
                if (bonusSpells.length === 0) {
                    html += '<div class="detail-content"><p class="muted-center">No bonus action spells available.</p></div>';
                } else {
                    // Sort bonus action spells alphabetically
                    const sortedSpells = [...bonusSpells].sort((a, b) => a.localeCompare(b));
                    html += '<div class="spells-section">';
                    html += '<div class="spells-section-title">‚ú® Bonus Action Spells</div>';
                    html += '<div class="spells-list">';
                    sortedSpells.forEach(spell => {
                        // Find spell level (assume level 1 for now, could be enhanced)
                        const level = 1;
                        html += `<div class="spell-item" onclick="handleSpellCast('${spell.replace(/'/g, "\\'")}', ${level}, 'bonus')">${spell}</div>`;
                    });
                    html += '</div>';
                    html += '</div>';
                }
            } else {
                // Show cantrips and action spells
                if (hasCantrips) {
                    html += '<div class="spells-section">';
                    html += '<div class="spells-section-title">‚ú® Cantrips</div>';
                    html += '<div class="spells-list">';
                    const sortedCantrips = [...profile.cantrips].sort((a, b) => a.localeCompare(b));
                    sortedCantrips.forEach(spell => {
                        html += `<div class="spell-item" onclick="handleSpellCast('${spell.replace(/'/g, "\\'")}', 0, 'action')">${spell}</div>`;
                    });
                    html += '</div>';
                    html += '</div>';
                }

                // Show action spells by level
                if (hasSpellSlots) {
                    const spellLevels = Object.keys(profile.spellSlots)
                        .map(level => parseInt(level, 10))
                        .filter(level => level >= 1 && level <= 9)
                        .sort((a, b) => a - b);

                    spellLevels.forEach(level => {
                        const totalSlots = profile.spellSlots[level] || 0;
                        const usedSlots = state.spellSlotsUsed[level] || 0;
                        const remainingSlots = totalSlots - usedSlots;

                        // Get action spells for this level
                        const actionSpells = getActionSpells(profile);
                        if (actionSpells.length === 0 && level === 1) return; // Skip if no action spells

                        html += '<div class="spells-section">';
                        html += `<div class="spells-section-title">Level ${level}`;
                        if (totalSlots > 0) {
                            html += ` <span class="spell-slots-info">`;
                            if (remainingSlots > 0) {
                                html += `<span class="spell-slots-remaining">${remainingSlots}/${totalSlots} slots remaining</span>`;
                            } else {
                                html += `<span class="spell-slots-empty">0/${totalSlots} slots remaining</span>`;
                            }
                            html += `</span>`;
                        }
                        html += '</div>';

                        if (level === 1 && actionSpells.length > 0) {
                            html += '<div class="spells-list">';
                            const sortedSpells = [...actionSpells].sort((a, b) => a.localeCompare(b));
                            sortedSpells.forEach(spell => {
                                html += `<div class="spell-item" onclick="handleSpellCast('${spell.replace(/'/g, "\\'")}', ${level}, 'action')">${spell}</div>`;
                            });
                            html += '</div>';
                        } else if (level > 1) {
                            html += '<div class="spells-list">';
                            html += '<div class="spell-item" style="color: var(--text-light); font-style: italic;">No spells of this level</div>';
                            html += '</div>';
                        }
                        html += '</div>';
                    });
                } else if (profile.spells && profile.spells.length > 0) {
                    // If no spell slots but has spells, show action spells under Level 1
                    const actionSpells = getActionSpells(profile);
                    if (actionSpells.length > 0) {
                        html += '<div class="spells-section">';
                        html += '<div class="spells-section-title">Level 1</div>';
                        html += '<div class="spells-list">';
                        const sortedSpells = [...actionSpells].sort((a, b) => a.localeCompare(b));
                        sortedSpells.forEach(spell => {
                            html += `<div class="spell-item" onclick="handleSpellCast('${spell.replace(/'/g, "\\'")}', 1, 'action')">${spell}</div>`;
                        });
                        html += '</div>';
                        html += '</div>';
                    }
                }
            }

            content.innerHTML = html;
            showScreen(screenId);
        }

        // Pending spell cast (stored while waiting for slot confirmation)
        let pendingSpellCast = null;

        // Handle spell cast
        function handleSpellCast(spellName, level, actionType) {
            // level 0 = cantrip, level >= 1 = leveled spell
            // actionType = 'action' or 'bonus'
            
            if (level === 0) {
                // Cantrip - no slot needed, just log it and mark action as used
                logSpellCast(spellName, 0);
                if (actionType === 'action') {
                    state.action = 'used';
                    state.actionUsedBy = 'spell';
                } else if (actionType === 'bonus') {
                    state.bonusAction = 'used';
                }
                saveState();
                updateUI();
                showToast(`Cast: ${spellName}`);
                // Return to home screen
                showScreen('screen-home');
            } else {
                // Leveled spell - check if slots available and prompt
                const profile = getActiveCharacterProfile();
                if (!profile || !profile.spellSlots || !profile.spellSlots[level]) {
                    showToast(`No spell slots available for level ${level}`);
                    return;
                }

                const totalSlots = profile.spellSlots[level] || 0;
                const usedSlots = state.spellSlotsUsed[level] || 0;
                const remainingSlots = totalSlots - usedSlots;

                if (remainingSlots <= 0) {
                    showToast(`No level ${level} spell slots remaining`);
                    return;
                }

                // Store pending cast (including action type)
                pendingSpellCast = { spellName, level, actionType };

                // Show prompt dialog if confirmSpends is enabled, otherwise auto-confirm
                if (prefs.confirmSpends) {
                    const dialog = document.getElementById('spell-slot-dialog');
                    const message = document.getElementById('spell-slot-dialog-message');
                    message.textContent = `Cast ${spellName}? Spend a level ${level} spell slot? (${remainingSlots - 1}/${totalSlots} remaining)`;
                    dialog.classList.add('active');
                } else {
                    confirmSpellSlotSpend();
                }
            }
        }

        // Confirm spell slot spending
        function confirmSpellSlotSpend() {
            if (!pendingSpellCast) return;

            const { spellName, level, actionType } = pendingSpellCast;

            // Decrement slot
            if (!state.spellSlotsUsed[level]) {
                state.spellSlotsUsed[level] = 0;
            }
            state.spellSlotsUsed[level]++;

            // Mark action/bonus action as used
            if (actionType === 'action') {
                state.action = 'used';
                state.actionUsedBy = 'spell';
            } else if (actionType === 'bonus') {
                state.bonusAction = 'used';
            }

            // Log the cast
            logSpellCast(spellName, level);

            // Save state
            saveState();

            // Close dialog
            closeSpellSlotDialog();

            // Update UI
            updateUI();

            // Show toast
            const profile = getActiveCharacterProfile();
            const totalSlots = profile?.spellSlots?.[level] || 0;
            const usedSlots = state.spellSlotsUsed[level] || 0;
            const remainingSlots = totalSlots - usedSlots;
            showToast(`Cast: ${spellName} (${remainingSlots}/${totalSlots} slots remaining)`);

            // Clear pending and return to home
            pendingSpellCast = null;
            showScreen('screen-home');
        }

        // Cancel spell slot spending
        function cancelSpellSlotSpend() {
            closeSpellSlotDialog();
            pendingSpellCast = null;
        }

        // Close spell slot dialog
        function closeSpellSlotDialog() {
            document.getElementById('spell-slot-dialog').classList.remove('active');
        }

        // Log spell cast to turn log
        function logSpellCast(spellName, level) {
            const entry = {
                action: 'cast',
                spell: spellName,
                level: level
            };

            // Add timestamp if enabled (default: enabled)
            if (prefs.turnLogTimestamps !== false) {
                const now = new Date();
                entry.timestamp = now.toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit' 
                });
            }

            state.turnLog.push(entry);
            saveState();
            updateTurnLog();
        }

        // Update turn log display
        function updateTurnLog() {
            const turnLogContainer = document.getElementById('turn-log');
            const turnLogEntries = document.getElementById('turn-log-entries');

            if (!turnLogContainer || !turnLogEntries) return;

            if (state.turnLog && state.turnLog.length > 0) {
                turnLogContainer.style.display = 'block';
                let html = '';
                state.turnLog.forEach(entry => {
                    if (entry.action === 'cast') {
                        const levelText = entry.level === 0 ? 'Cantrip' : `Level ${entry.level}`;
                        html += `<div class="turn-log-entry">`;
                        if (entry.timestamp) {
                            html += `<span class="turn-log-entry-time">${entry.timestamp}</span>`;
                        }
                        html += `<span>‚ú® Cast ${entry.spell} (${levelText})</span>`;
                        html += `</div>`;
                    }
                });
                turnLogEntries.innerHTML = html;
            } else {
                turnLogContainer.style.display = 'none';
            }
        }

        // Clear turn log
        function clearTurnLog() {
            if (confirm('Clear turn log?')) {
                state.turnLog = [];
                saveState();
                updateTurnLog();
            }
        }

        // Update speed display in Move modal
        function updateMoveSpeedDisplay() {
            const speedDisplay = document.getElementById('move-speed-display');
            const speedNumber = document.getElementById('move-speed-number');
            const speedType = document.getElementById('move-speed-type');
            const descriptionText = document.getElementById('move-description-text');
            
            if (!speedDisplay || !speedNumber || !speedType || !descriptionText) return;
            
            // Try to get speed from active character profile
            let speed = null;
            try {
                const profile = getActiveCharacterProfile();
                if (profile && profile.speed !== undefined && profile.speed !== null) {
                    speed = profile.speed;
                }
            } catch (e) {
                // Ignore errors
            }
            
            if (speed !== null && speed > 0) {
                // Show speed display and update values
                speedDisplay.style.display = 'block';
                speedNumber.textContent = speed;
                speedType.textContent = 'Walking';
                
                // Update description text with actual speed
                descriptionText.textContent = `On your turn, you can move a distance up to your speed. You can use some of your movement before and after your action. For example, if you have a speed of ${speed} feet, you can move ${Math.floor(speed / 3)} feet, take your action, and then move ${Math.floor(speed * 2 / 3)} feet more.`;
            } else {
                // Hide speed display if no speed available
                speedDisplay.style.display = 'none';
                descriptionText.textContent = 'On your turn, you can move a distance up to your speed. You can use some of your movement before and after your action. For example, if you have a speed of 30 feet, you can move 10 feet, take your action, and then move 20 feet more.';
            }
        }

        // Toast Notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);
        }

        // MOVE
        function handleMove() {
            if (state.movement === 'used') {
                showToast('Movement already used.');
                return;
            }
            state.pendingAction = 'move';
            if (prefs.confirmSpends) {
                showScreen('screen-move-detail');
            } else {
                confirmMove();
            }
        }

        // DASH
        function handleDash() {
            if (state.action === 'used') {
                showToast('Action already used.');
                return;
            }
            state.pendingAction = 'dash';
            if (prefs.confirmSpends) {
                showScreen('screen-dash-detail');
            } else {
                confirmDash();
            }
        }

        // Handle Action Click (with check)
        function handleActionClick() {
            if (state.action === 'used') {
                showToast('Action already used.');
                return;
            }
            showScreen('screen-action');
        }

        // Handle Bonus Action Click (with check)
        function handleBonusActionClick() {
            if (state.bonusAction === 'used') {
                showToast('Bonus Action already used.');
                return;
            }
            if (!hasBonusActionOptions()) {
                showToast('No bonus actions configured.');
                return;
            }
            renderBonusActionOptions();
            showScreen('screen-bonus-action');
        }

        // Handle Interact Click (with check)
        function handleInteractClick() {
            if (state.interaction === 'used') {
                showToast('Interaction already used.');
                return;
            }
            showScreen('screen-interact');
        }

        function renderBonusActionOptions() {
            const container = document.getElementById('bonus-action-options');
            if (!container) return;
            container.innerHTML = '';

            const options = getBonusActionOptions();
            
            // Check if character has bonus action spells
            const profile = getActiveCharacterProfile();
            const hasBonusActionSpells = profile && getBonusActionSpells(profile).length > 0;
            
            if (hasBonusActionSpells) {
                const btn = document.createElement('button');
                btn.className = 'btn btn-primary';
                btn.type = 'button';
                btn.textContent = '‚ú® Cast a Spell';
                btn.onclick = () => showSpellSelection('bonus');
                container.appendChild(btn);
            }

            if (options.length === 0 && !hasBonusActionSpells) {
                const wrap = document.createElement('div');
                wrap.className = 'detail-content';
                wrap.innerHTML = '<p class="muted-center">All set.</p>';
                container.appendChild(wrap);
                return;
            }

            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'btn btn-primary';
                btn.type = 'button';
                btn.textContent = opt.label;
                btn.onclick = () => showBonusActionDetail(opt.key);
                container.appendChild(btn);
            });
        }

        // Confirm Move
        function confirmMove() {
            state.movement = 'used';
            state.pendingAction = null;
            updateUI();
            showScreen('screen-home');
        }

        // Confirm Dash
        function confirmDash() {
            state.action = 'used';
            state.dashActive = true;
            state.actionUsedBy = 'dash';
            state.pendingAction = null;
            updateUI();
            showScreen('screen-home');
        }

        // INTERACT
        function handleInteract(type) {
            state.pendingAction = 'interact';
            state.pendingInteractType = type;
            
            const interactDetails = {
                'draw-stow': {
                    title: 'üó°Ô∏è Draw/Stow Weapon',
                    content: '<p><strong>Draw or sheathe one weapon.</strong></p><p>You can interact with one object or feature of the environment for free during your move or action. For example, you could open a door during your move as you stride toward a foe, or you could draw your weapon as part of the same action you use to attack.</p><p>If you want to interact with a second object, you need to use your action. Some magic items and other special objects always require an action to use, as stated in their descriptions.</p>'
                },
                'door': {
                    title: 'üö™ Open/Close Door',
                    content: '<p><strong>Open or close an unlocked door.</strong></p><p>You can interact with one object or feature of the environment for free during your move or action. Opening or closing a door is a common example of this type of interaction.</p><p>If you want to interact with a second object, you need to use your action.</p>'
                },
                'pickup-drop': {
                    title: 'üì¶ Pick Up / Drop Item',
                    content: '<p><strong>Pick up an item from ground or drop held item.</strong></p><p>You can interact with one object or feature of the environment for free during your move or action. Picking up or dropping an item is a common example of this type of interaction.</p><p>Dropping an item is always free. Picking up an item is a free object interaction, but only one per turn.</p><p>If you want to interact with a second object, you need to use your action.</p>'
                },
                'move-object': {
                    title: 'ü™ë Move Small Object',
                    content: '<p><strong>Move a chair, table, or small object to create cover or clear a path.</strong></p><p>You can interact with one object or feature of the environment for free during your move or action. Moving a small object like a chair or table is a common example of this type of interaction.</p><p>This can be used to create cover, block a doorway, or clear a path. If you want to interact with a second object, you need to use your action.</p>'
                }
            };

            const detail = interactDetails[type];
            if (detail) {
                if (prefs.confirmSpends) {
                    document.getElementById('interact-detail-title').textContent = detail.title;
                    document.getElementById('interact-detail-content').innerHTML = detail.content;
                    showScreen('screen-interact-detail');
                } else {
                    confirmInteract();
                }
            }
        }

        // Confirm Interact
        function confirmInteract() {
            state.interaction = 'used';
            state.pendingAction = null;
            state.pendingInteractType = null;
            updateUI();
            showScreen('screen-home');
        }

        // Toggle Reaction
        function toggleReaction() {
            // Can't toggle if reserved (from Ready action)
            if (state.reaction === 'reserved') {
                return;
            }
            
            // Toggle between available and used
            if (state.reaction === 'available') {
                state.reaction = 'used';
            } else if (state.reaction === 'used') {
                state.reaction = 'available';
            }
            
            // Update reaction widget and save state
            updateReactionWidget();
            saveState();
        }

        // Per-button undo handlers
        function handleUndoMove() {
            if (confirm('Undo MOVE?')) {
                state.movement = 'available';
                updateUI();
            }
        }
        
        function handleUndoDash() {
            if (confirm('Undo DASH?')) {
                state.action = 'available';
                state.dashActive = false;
                state.actionUsedBy = null;
                updateUI();
            }
        }
        
        function handleUndoAction() {
            if (confirm('Undo ACTION?')) {
                // If action was used for dash, clear dashActive
                if (state.actionUsedBy === 'dash') {
                    state.dashActive = false;
                }
                // If reaction is reserved (from Ready action), restore it
                if (state.reaction === 'reserved') {
                    state.reaction = 'available';
                }
                state.action = 'available';
                state.actionUsedBy = null;
                updateUI();
            }
        }
        
        function handleUndoBonusAction() {
            if (confirm('Undo BONUS ACTION?')) {
                state.bonusAction = 'available';
                updateUI();
            }
        }
        
        function handleUndoInteract() {
            if (confirm('Undo INTERACT?')) {
                state.interaction = 'available';
                updateUI();
            }
        }

        // Confirm Action Detail
        function confirmActionDetail() {
            if (state.pendingActionType === 'ready') {
                state.action = 'used';
                state.reaction = 'reserved';
            } else {
                state.action = 'used';
            }
            
            state.actionUsedBy = 'other';

            state.pendingAction = null;
            state.pendingActionType = null;
            updateUI();
            showScreen('screen-home');
        }

        // Action Details
        const actionDetails = {
            'search': {
                title: 'üîç Search',
                content: '<p><strong>Make a Perception or Investigation check to find hidden objects, creatures, or details.</strong></p><p>When you take the Search action, you devote your attention to finding something. Depending on the nature of your search, the DM might have you make a Wisdom (Perception) check or an Intelligence (Investigation) check.</p>'
            },
            'ready': {
                title: '‚è≥ Ready',
                content: '<p><strong>Hold your action until a trigger occurs. Uses your reaction when triggered.</strong></p><p>Sometimes you want to get the jump on a foe or wait for a particular circumstance before you act. To do so, you can take the Ready action on your turn, which lets you act using your reaction before the start of your next turn.</p><p>First, you decide what perceivable circumstance will trigger your reaction. Then, you choose the action you will take in response to that trigger, or you choose to move up to your speed in response to it. Examples include "If the cultist steps on the trapdoor, I\'ll pull the lever that opens it," and "If the goblin steps next to me, I move away."</p><p><strong>When the trigger occurs, you can either take your reaction right after the trigger finishes or ignore the trigger. Remember that you can take only one reaction per round.</strong></p>'
            },
            'help': {
                title: 'ü§ù Help',
                content: '<p><strong>Grant advantage to an ally\'s next ability check or attack roll against a target within 5 feet.</strong></p><p>You can lend your aid to another creature in the completion of a task. When you take the Help action, the creature you aid gains advantage on the next ability check it makes to perform the task you are helping with, provided that it makes the check before the start of your next turn.</p><p>Alternatively, you can aid a friendly creature in attacking a creature within 5 feet of you. You feint, distract the target, or in some other way team up to make your ally\'s attack more effective. If your ally attacks the target before your next turn, the first attack roll is made with advantage.</p>'
            },
            'dodge': {
                title: 'üõ°Ô∏è Dodge',
                content: '<p><strong>Impose disadvantage on attack rolls against you. Dex saves with advantage until start of next turn.</strong></p><p>When you take the Dodge action, you focus entirely on avoiding attacks. Until the start of your next turn, any attack roll made against you has disadvantage if you can see the attacker, and you make Dexterity saving throws with advantage. You lose this benefit if you are incapacitated or if your speed drops to 0.</p>'
            },
            'disengage': {
                title: 'üèÉ‚Äç‚ôÇÔ∏è Disengage',
                content: '<p><strong>Your movement doesn\'t provoke opportunity attacks this turn.</strong></p><p>If you take the Disengage action, your movement doesn\'t provoke opportunity attacks for the rest of the turn.</p>'
            },
            'hide': {
                title: 'ü•∑ Hide',
                content: '<p><strong>Make a Dexterity (Stealth) check to become hidden. Must be behind cover or heavily obscured.</strong></p><p>When you take the Hide action, you make a Dexterity (Stealth) check in an attempt to hide, following the rules for hiding. If you succeed, you gain certain benefits, as described in the "Unseen Attackers and Targets" section later in this chapter.</p><p>You can\'t hide from a creature that can see you, and if you make noise (such as shouting a warning or knocking over a vase), you give away your position. An invisible creature can\'t be seen, so it can always try to hide. Signs of its passage might still be noticed, however, and it still has to stay quiet.</p><p>In combat, most creatures stay alert for signs of danger all around, so if you come out of hiding and approach a creature, it usually sees you. However, under certain circumstances, the DM might allow you to stay hidden as you approach a creature that is distracted, allowing you to gain advantage on an attack before you are seen.</p>'
            },
            'use-object': {
                title: 'üîß Use Object (Complex)',
                content: '<p><strong>Complex object use - potion, device, tool, DM call.</strong></p><p>You normally interact with an object while doing something else, such as when you draw a sword as part of an attack. When an object requires your action for its use, you take the Use an Object action. This action is also useful when you want to interact with more than one object on your turn.</p><p>Some magic items and other special objects always require an action to use, as stated in their descriptions.</p><p><strong>This is separate from your free object interaction (INTERACT). Examples include drinking a potion, activating a magic item, using a device, or other complex object interactions as determined by the DM.</strong></p>'
            },
            'cast-spell': {
                title: '‚ú® Cast a Spell',
                content: '<p><strong>Cast a spell with casting time of 1 action.</strong></p><p>Spellcasters such as wizards and clerics, as well as many monsters, have access to spells and can use them to great effect in combat. Each spell has a casting time, which specifies whether the caster must use an action, a reaction, minutes, or even hours to cast the spell. Casting a spell is, therefore, not necessarily an action. Most spells have a casting time of 1 action, so a spellcaster often uses his or her action in combat to cast such a spell.</p>'
            },
            'shove': {
                title: 'üí™ Shove',
                content: '<p><strong>Make a Strength (Athletics) contest. On success, push target 5 feet away or knock prone.</strong></p><p>Using the Attack action, you can make a special melee attack to shove a creature, either to knock it prone or push it away from you. If you\'re able to make multiple attacks with the Attack action, this attack replaces one of them.</p><p>The target must be no more than one size larger than you and must be within your reach. Instead of making an attack roll, you make a Strength (Athletics) check contested by the target\'s Strength (Athletics) or Dexterity (Acrobatics) check (the target chooses the ability to use). If you win the contest, you either knock the target prone or push it 5 feet away from you.</p>'
            },
            'grapple': {
                title: 'ü§º Grapple',
                content: '<p><strong>Make a Strength (Athletics) contest. On success, target is grappled (speed becomes 0).</strong></p><p>Using the Attack action, you can make a special melee attack to grapple a creature. If you\'re able to make multiple attacks with the Attack action, this attack replaces one of them.</p><p>The target of your grapple must be no more than one size larger than you and must be within your reach. Using at least one free hand, you try to seize the target by making a grapple check instead of an attack roll: a Strength (Athletics) check contested by the target\'s Strength (Athletics) or Dexterity (Acrobatics) check (the target chooses the ability to use). If you succeed, you subject the target to the grappled condition. The condition specifies the things that end it, and you can release the target whenever you like (no action required).</p>'
            }
        };

        function showActionDetail(actionType) {
            const detail = actionDetails[actionType];
            if (detail) {
                state.pendingAction = 'action';
                state.pendingActionType = actionType;
                if (prefs.confirmSpends) {
                    document.getElementById('action-detail-title').textContent = detail.title;
                    document.getElementById('action-detail-content').innerHTML = detail.content;
                    showScreen('screen-action-detail');
                } else {
                    confirmActionDetail();
                }
            }
        }

        // Bonus Action Details
        const bonusActionDetails = {
            'healing-word': {
                title: 'üíö Healing Word',
                content: '<p><strong>Cast Healing Word as a bonus action. Target regains hit points.</strong></p><p>A creature of your choice that you can see within range regains hit points equal to 1d4 + your spellcasting ability modifier. This spell has no effect on undead or constructs.</p><p><strong>At Higher Levels:</strong> When you cast this spell using a spell slot of 2nd level or higher, the healing increases by 1d4 for each slot level above 1st.</p>'
            },
            'class-feature': {
                title: 'üé≠ Class Feature',
                content: '<p><strong>Use a class feature that takes a bonus action.</strong></p><p>Various class features can be used as a bonus action. Examples include:</p><ul><li><strong>Rogue - Cunning Action:</strong> Dash, Disengage, or Hide as a bonus action</li><li><strong>Barbarian - Rage:</strong> Enter a rage as a bonus action</li><li><strong>Monk - Flurry of Blows:</strong> Make unarmed strikes as a bonus action</li><li><strong>Ranger - Hunter\'s Mark:</strong> Cast Hunter\'s Mark as a bonus action</li></ul><p>Consult your class features for other bonus action options available to you.</p>'
            },
            'offhand-attack': {
                title: 'üó°Ô∏è Offhand Attack',
                content: '<p><strong>Make an attack with a light weapon in your off hand.</strong></p><p>When you take the Attack action and attack with a light melee weapon that you\'re holding in one hand, you can use a bonus action to attack with a different light melee weapon that you\'re holding in the other hand. You don\'t add your ability modifier to the damage of the bonus attack, unless that modifier is negative.</p><p>If either weapon has the thrown property, you can throw the weapon, instead of making a melee attack with it.</p><p><strong>Two-Weapon Fighting Style:</strong> If you have the Two-Weapon Fighting style, you can add your ability modifier to the damage of the bonus attack.</p>'
            }
        };

        function showBonusActionDetail(bonusType) {
            let detail = bonusActionDetails[bonusType];
            if (bonusType === 'class-feature') {
                detail = getClassFeatureBonusAction();
            }
            if (detail) {
                state.pendingAction = 'bonus-action';
                state.pendingBonusActionType = bonusType;
                if (prefs.confirmSpends) {
                    document.getElementById('bonus-action-detail-title').textContent = detail.title;
                    document.getElementById('bonus-action-detail-content').innerHTML = detail.content;
                    showScreen('screen-bonus-action-detail');
                } else {
                    confirmBonusAction();
                }
            } else {
                showToast('No class bonus action configured.');
            }
        }

        // Confirm Bonus Action
        function confirmBonusAction() {
            state.bonusAction = 'used';
            state.pendingAction = null;
            state.pendingBonusActionType = null;
            updateUI();
            showScreen('screen-home');
        }

        // Attack Tree
        function showAttackTree() {
            state.pendingAction = 'attack';
            state.currentAttackStep = 1;
            showScreen('screen-attack');
            
            // Hide all attack steps first
            document.querySelectorAll('.attack-tree').forEach(step => {
                step.classList.remove('active');
            });
            
            // Show first step
            document.getElementById('attack-step-1').classList.add('active');
        }

        function showAttackStep(step, type) {
            // Hide all attack steps
            document.querySelectorAll('.attack-tree').forEach(step => {
                step.classList.remove('active');
            });

            if (step === 1) {
                document.getElementById('attack-step-1').classList.add('active');
                state.currentAttackStep = 1;
            } else if (step === 2) {
                if (type === 'weapon') {
                    document.getElementById('attack-weapon').classList.add('active');
                    state.lastAttackType = 'weapon';
                    // Show/hide Extra Attack reminder based on setting
                    const extraAttackReminder = document.getElementById('extra-attack-reminder');
                    if (extraAttackReminder) {
                        extraAttackReminder.style.display = prefs.extraAttackReminder ? 'block' : 'none';
                    }
                } else if (type === 'spell') {
                    document.getElementById('attack-spell').classList.add('active');
                    state.lastAttackType = 'spell';
                } else if (type === 'save') {
                    document.getElementById('attack-save-type').classList.add('active');
                    state.lastAttackType = 'save';
                } else if (type && type.startsWith('save-')) {
                    const saveType = type.replace('save-', '').toUpperCase();
                    document.getElementById('save-type-name').textContent = saveType;
                    document.getElementById('attack-save-result').classList.add('active');
                    state.lastAttackType = type; // Store the save ability type
                }
                state.currentAttackStep = 2;
            } else if (step === 3) {
                // Combined hit/miss/save result screen
                const resultContent = document.getElementById('attack-result-content');
                if (type === 'hit') {
                    resultContent.innerHTML = '<p><strong>Roll damage dice + modifier</strong></p>';
                    // Show Extra Attack reminder if enabled
                    if (prefs.extraAttackReminder) {
                        resultContent.innerHTML += '<div style="margin-top: 1rem; padding: 0.75rem; background-color: rgba(0, 0, 0, 0.05); border-radius: 4px;"><p style="margin-bottom: 0.5rem; font-weight: 600;">Extra Attack Reminder:</p><p style="margin: 0.25rem 0;">If you have Extra Attack, you can make another attack.</p></div>';
                    }
                } else if (type === 'miss') {
                    resultContent.innerHTML = '<p><strong>Miss!</strong></p><p><strong>Follow-up suggestions:</strong></p><ul><li>Move to better position or cover</li><li>Help an ally on your next turn</li><li>Try Shove to push or knock prone</li><li>Try Grapple to restrain target</li><li>Use environment (close door, tip table for cover)</li></ul>';
                } else if (type === 'save-succeeds') {
                    resultContent.innerHTML = '<p><strong>Save Succeeds:</strong> Reduced or no effect (as per spell)</p>';
                } else if (type === 'save-fails') {
                    resultContent.innerHTML = '<p><strong>Save Fails:</strong> Full effect applied</p>';
                }
                document.getElementById('attack-result').classList.add('active');
                state.currentAttackStep = 3;
            }
        }

        function attackStep(step, type) {
            showAttackStep(step, type);
        }

        // Handle back button from attack result screen
        function goBackFromAttackResult() {
            if (state.lastAttackType && state.lastAttackType.startsWith('save-')) {
                // For save attacks, go back to save result screen
                attackStep(2, state.lastAttackType);
            } else if (state.lastAttackType === 'weapon' || state.lastAttackType === 'spell') {
                // For weapon/spell attacks, go back to weapon/spell screen
                attackStep(2, state.lastAttackType);
            } else {
                // Fallback to step 1
                attackStep(1);
            }
        }

        // Confirm Attack Action
        function confirmAttackAction() {
            state.action = 'used';
            state.actionUsedBy = 'other';
            state.pendingAction = null;
            updateUI();
            showScreen('screen-home');
        }

        // End Turn - Streamlined: go directly to checklist, show quick actions there if needed
        function handleEndTurn() {
            proceedToEndTurnScreen();
        }

        function proceedToEndTurnScreen() {
            // Update checklist
            document.getElementById('checklist-movement').textContent = state.movement === 'used' ? 'Used' : 'Unused';
            document.getElementById('checklist-movement').className = 'status ' + (state.movement === 'used' ? 'used' : 'unused');
            document.getElementById('checklist-action').textContent = state.action === 'used' ? 'Used' : 'Unused';
            document.getElementById('checklist-action').className = 'status ' + (state.action === 'used' ? 'used' : 'unused');
            
            // Only show Bonus Action in checklist if enabled
            const bonusActionItem = document.getElementById('checklist-bonus-action').parentElement;
            if (prefs.bonusActionEnabled && hasBonusActionOptions()) {
                bonusActionItem.style.display = '';
                document.getElementById('checklist-bonus-action').textContent = state.bonusAction === 'used' ? 'Used' : 'Unused';
                document.getElementById('checklist-bonus-action').className = 'status ' + (state.bonusAction === 'used' ? 'used' : 'unused');
            } else {
                bonusActionItem.style.display = 'none';
            }
            
            // Only show Interaction in checklist if tracking is enabled
            const interactionItem = document.getElementById('checklist-interaction-item');
            if (prefs.trackInteraction) {
                interactionItem.style.display = '';
                document.getElementById('checklist-interaction').textContent = state.interaction === 'used' ? 'Used' : 'Unused';
                document.getElementById('checklist-interaction').className = 'status ' + (state.interaction === 'used' ? 'used' : 'unused');
            } else {
                interactionItem.style.display = 'none';
            }
            
            // Show quick actions if resources are available
            const resources = countAvailableResources();
            const quickActionsEl = document.getElementById('end-turn-quick-actions');
            const quickButtonsEl = document.getElementById('end-turn-quick-buttons');
            
            if (resources.count > 0 && quickActionsEl && quickButtonsEl) {
                quickButtonsEl.innerHTML = '';
                
                if (state.movement === 'available') {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-secondary btn-small';
                    btn.textContent = 'Mark Movement Used';
                    btn.onclick = () => {
                        state.movement = 'used';
                        updateUI();
                        proceedToEndTurnScreen(); // Refresh
                    };
                    quickButtonsEl.appendChild(btn);
                }
                
                if (prefs.trackInteraction && state.interaction === 'available') {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-secondary btn-small';
                    btn.textContent = 'Mark Interaction Used';
                    btn.onclick = () => {
                        state.interaction = 'used';
                        updateUI();
                        proceedToEndTurnScreen(); // Refresh
                    };
                    quickButtonsEl.appendChild(btn);
                }
                
                if (prefs.bonusActionEnabled && state.bonusAction === 'available' && hasBonusActionOptions()) {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-secondary btn-small';
                    btn.textContent = 'Mark Bonus Action Used';
                    btn.onclick = () => {
                        state.bonusAction = 'used';
                        updateUI();
                        proceedToEndTurnScreen(); // Refresh
                    };
                    quickButtonsEl.appendChild(btn);
                }
                
                quickActionsEl.style.display = quickButtonsEl.children.length > 0 ? 'block' : 'none';
            } else if (quickActionsEl) {
                quickActionsEl.style.display = 'none';
            }
            
            showScreen('screen-end-turn');
        }

        function closeEndTurnDialog() {
            document.getElementById('end-turn-dialog').classList.remove('active');
        }

        function confirmEndTurnAnyway() {
            closeEndTurnDialog();
            proceedToEndTurnScreen();
        }

        function confirmEndTurn() {
            // Reset resources
            state.movement = 'available';
            state.action = 'available';
            state.bonusAction = 'available';
            state.interaction = 'available';
            // Reaction does NOT reset (resets at START of turn)
            state.dashActive = false;
            state.actionUsedBy = null;
            // Spell slots do NOT reset (they reset on long rest, not end of turn)

            updateUI();
            showScreen('screen-not-your-turn');
        }

        // Start Turn
        function handleStartTurn() {
            // Reset reaction at START of turn (per 5e rules)
            if (state.reaction === 'reserved') {
                state.reaction = 'available';
            } else {
                state.reaction = 'available';
            }
            
            // Auto-reset resources if setting is enabled
            if (prefs.autoResetOnStartTurn) {
                state.movement = 'available';
                state.action = 'available';
                state.bonusAction = 'available';
                state.interaction = 'available';
                state.dashActive = false;
                state.actionUsedBy = null;
                // Note: Spell slots are NOT reset on start turn (they reset on long rest)
            }
            
            updateUI();
            showScreen('screen-home');
        }

        // Reset All
        function showResetDialog() {
            document.getElementById('reset-dialog').classList.add('active');
        }

        function closeResetDialog() {
            document.getElementById('reset-dialog').classList.remove('active');
        }

        function confirmReset() {
            // Clear localStorage
            localStorage.removeItem('combatTurnState');
            
            // Reset state to defaults
            state = {
                movement: 'available',
                action: 'available',
                bonusAction: 'available',
                interaction: 'available',
                reaction: 'available',
                dashActive: false,
                actionUsedBy: null,
                currentAttackStep: 1,
                currentSaveType: null,
                pendingAction: null,
                spellSlotsUsed: {},  // Reset spell slots usage
                turnLog: []  // Reset turn log
            };
            
            // Update UI and go to home
            updateUI();
            closeResetDialog();
            showScreen('screen-home');
        }

        // PDF Import Functions
        let pendingCharacterProfile = null;

        // Active Character Management
        const ACTIVE_CHARACTER_ID_KEY = 'activeCharacterId';
        const CHARACTER_PROFILE_PREFIX = 'characterProfileV1:';

        // Generate a unique character ID
        function generateCharacterId() {
            return 'char_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Get active character ID
        function getActiveCharacterId() {
            return localStorage.getItem(ACTIVE_CHARACTER_ID_KEY);
        }

        // Set active character ID
        function setActiveCharacterId(id) {
            localStorage.setItem(ACTIVE_CHARACTER_ID_KEY, id);
        }

        // Get active character profile
        function getActiveCharacterProfile() {
            const activeId = getActiveCharacterId();
            if (activeId) {
                try {
                    const profileData = localStorage.getItem(CHARACTER_PROFILE_PREFIX + activeId);
                    if (profileData) {
                        return JSON.parse(profileData);
                    }
                } catch (e) {
                    console.error('Failed to load active character profile:', e);
                }
            }
            
            // Backward compatibility: migrate old 'characterProfile' if it exists
            try {
                const oldProfile = localStorage.getItem('characterProfile');
                if (oldProfile) {
                    const profile = JSON.parse(oldProfile);
                    // Migrate to new format
                    if (!profile.id) {
                        profile.id = generateCharacterId();
                    }
                    saveCharacterProfile(profile, profile.id);
                    // Remove old key
                    localStorage.removeItem('characterProfile');
                    return profile;
                }
            } catch (e) {
                console.error('Failed to migrate old character profile:', e);
            }
            
            return null;
        }

        // Save character profile with ID
        function saveCharacterProfile(profile, id) {
            if (!id) {
                id = generateCharacterId();
            }
            localStorage.setItem(CHARACTER_PROFILE_PREFIX + id, JSON.stringify(profile));
            setActiveCharacterId(id);
            return id;
        }

        // Get all saved character profiles
        function getAllCharacterProfiles() {
            const profiles = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(CHARACTER_PROFILE_PREFIX)) {
                    try {
                        const id = key.replace(CHARACTER_PROFILE_PREFIX, '');
                        const profileData = localStorage.getItem(key);
                        if (profileData) {
                            const profile = JSON.parse(profileData);
                            profile.id = id; // Ensure ID is set
                            profiles.push(profile);
                        }
                    } catch (e) {
                        console.error('Failed to load character profile:', key, e);
                    }
                }
            }
            return profiles.sort((a, b) => {
                // Sort by name, then by creation time
                if (a.name && b.name) {
                    return a.name.localeCompare(b.name);
                }
                return 0;
            });
        }

        // Populate character library dropdown
        function populateCharacterLibrary() {
            const select = document.getElementById('character-library-select');
            if (!select) return;

            const profiles = getAllCharacterProfiles();
            const activeId = getActiveCharacterId();

            // Clear existing options except the first one
            select.innerHTML = '<option value="">(No Character)</option>';

            // Add character options
            profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.id;
                const displayName = profile.name || `Character ${profile.id.substring(0, 8)}`;
                const classLevel = profile.className && profile.level ? ` (${profile.className} ${profile.level})` : '';
                option.textContent = `${displayName}${classLevel}`;
                if (profile.id === activeId) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        // Switch to a different character
        function switchCharacter(characterId) {
            if (!characterId) {
                // Clear active character
                localStorage.removeItem(ACTIVE_CHARACTER_ID_KEY);
                showToast('No character selected');
                updateUI();
                return;
            }

            // Verify character exists
            const profileData = localStorage.getItem(CHARACTER_PROFILE_PREFIX + characterId);
            if (!profileData) {
                showToast('Character not found');
                populateCharacterLibrary();
                return;
            }

            // Set as active
            setActiveCharacterId(characterId);
            
            // Load character settings
            try {
                const profile = JSON.parse(profileData);
                applyCharacterProfileToSettings(profile);
                showToast(`Switched to ${profile.name || 'Character'}`);
            } catch (e) {
                console.error('Failed to load character:', e);
                showToast('Failed to load character');
            }

            updateUI();
        }

        // Create a new empty character
        function createNewCharacter() {
            const newProfile = {
                id: generateCharacterId(),
                name: 'New Character',
                className: '',
                level: 0,
                ac: undefined,
                hpMax: undefined,
                speed: undefined,
                initiativeBonus: undefined,
                spellAttackBonus: undefined,
                spellSaveDC: undefined,
                spellSlots: {},
                cantrips: [],
                spells: []
            };

            saveCharacterProfile(newProfile, newProfile.id);
            applyCharacterProfileToSettings(newProfile);
            populateCharacterLibrary();
            updateUI();
            showToast('New character created');
        }

        // Duplicate current character
        function duplicateCurrentCharacter() {
            const currentProfile = getActiveCharacterProfile();
            if (!currentProfile) {
                showToast('No character to duplicate');
                return;
            }

            // Create a copy with new ID
            const duplicated = JSON.parse(JSON.stringify(currentProfile));
            duplicated.id = generateCharacterId();
            duplicated.name = (currentProfile.name || 'Character') + ' (Copy)';

            saveCharacterProfile(duplicated, duplicated.id);
            applyCharacterProfileToSettings(duplicated);
            populateCharacterLibrary();
            updateUI();
            showToast('Character duplicated');
        }

        // Delete current character
        function deleteCurrentCharacter() {
            const activeId = getActiveCharacterId();
            if (!activeId) {
                showToast('No character to delete');
                return;
            }

            const profile = getActiveCharacterProfile();
            const characterName = profile?.name || 'Character';

            if (!confirm(`Delete "${characterName}"? This cannot be undone.`)) {
                return;
            }

            // Remove from localStorage
            localStorage.removeItem(CHARACTER_PROFILE_PREFIX + activeId);
            localStorage.removeItem(ACTIVE_CHARACTER_ID_KEY);

            // Clear settings
            prefs.classKey = '';
            prefs.canHealingWord = false;
            prefs.canOffhandAttack = false;
            prefs.bonusActionEnabled = false;
            savePrefs();

            // Update UI
            populateCharacterLibrary();
            updateUI();
            showToast('Character deleted');
        }

        // Export current character as JSON
        function exportCharacterJSON() {
            const profile = getActiveCharacterProfile();
            if (!profile) {
                showToast('No character to export');
                return;
            }

            // Create clean export (remove debug fields)
            const exportData = { ...profile };
            delete exportData._debugExtractedText;
            delete exportData._debugFields;

            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Generate filename from character name (sanitized)
            let filename = 'character';
            if (profile.name) {
                filename = profile.name
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }
            a.download = `${filename}.json`;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Character exported');
        }

        // Import character from JSON file
        function handleJsonImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.includes('json') && !file.name.toLowerCase().endsWith('.json')) {
                showToast('Please select a JSON file.');
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    
                    // Validate it's a character profile
                    if (typeof imported !== 'object' || (!imported.name && !imported.className)) {
                        showToast('Invalid character file format.');
                        event.target.value = '';
                        return;
                    }

                    // Generate new ID for imported character (don't reuse old ID)
                    if (imported.id) {
                        delete imported.id;
                    }
                    imported.id = generateCharacterId();

                    // Save and set as active
                    saveCharacterProfile(imported, imported.id);
                    applyCharacterProfileToSettings(imported);
                    populateCharacterLibrary();
                    updateUI();
                    
                    showToast(`Character "${imported.name || 'Imported Character'}" imported successfully!`);
                } catch (err) {
                    console.error('JSON import error:', err);
                    showToast('Failed to import JSON: ' + err.message);
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }

        async function extractPdfData(file) {
            try {
                if (typeof pdfjsLib === 'undefined') {
                    throw new Error('PDF.js library not loaded');
                }

                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdf.numPages;
                let fullText = '';

                // Extract text content from pages
                for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    
                    // Normalize: collapse multiple spaces to single spaces
                    const normalizedPageText = pageText.replace(/\s+/g, ' ').trim();
                    
                    // Preserve newlines at page boundaries
                    if (fullText && normalizedPageText) {
                        fullText += '\n';
                    }
                    fullText += normalizedPageText;
                }

                // Extract form field values (AcroForm fields) into a map
                const fieldMap = {}; // Object map: { fieldNameOrLabel: value }

                try {
                    // Method 1: Try getFieldObjects() if available
                    if (pdf.getFieldObjects && typeof pdf.getFieldObjects === 'function') {
                        const fieldObjects = await pdf.getFieldObjects();
                        if (fieldObjects && Array.isArray(fieldObjects)) {
                            for (const field of fieldObjects) {
                                if (field && field.fieldName && field.fieldValue) {
                                    const name = String(field.fieldName).trim();
                                    const value = String(field.fieldValue).trim();
                                    if (name && value && value !== '' && value !== 'null' && value !== 'undefined') {
                                        fieldMap[name] = value;
                                    }
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.log('getFieldObjects() not available or failed:', e.message);
                }

                // Method 2: Extract annotations from each page (may contain form fields)
                try {
                    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                        const page = await pdf.getPage(pageNum);
                        const annotations = await page.getAnnotations();
                        
                        if (annotations && Array.isArray(annotations)) {
                            // DEBUG: Log annotation structure for first page
                            if (pageNum === 1 && annotations.length > 0) {
                                console.log('Sample annotation structure (first annotation):', JSON.stringify(annotations[0], null, 2));
                            }
                            
                            for (const annotation of annotations) {
                                // Check for form field annotations - try multiple property names
                                const fieldName = annotation.fieldName || annotation.T || annotation.FT || annotation.name;
                                const fieldValue = annotation.fieldValue || annotation.V || annotation.value || annotation.defaultFieldValue;
                                
                                if (fieldName && fieldValue) {
                                    const name = String(fieldName).trim();
                                    const value = String(fieldValue).trim();
                                    if (name && value && value !== '' && value !== 'null' && value !== 'undefined') {
                                        // Store in map (overwrite if duplicate, keeping last value)
                                        if (!fieldMap[name] || value.length > fieldMap[name].length) {
                                            fieldMap[name] = value;
                                        }
                                    }
                                }
                                
                                // Also check annotation subtype for widget annotations (form fields)
                                if (annotation.subtype === 'Widget' && annotation.fieldName) {
                                    const name = String(annotation.fieldName).trim();
                                    // Try to get value from various possible locations
                                    let value = annotation.fieldValue || annotation.V || annotation.value;
                                    if (value) {
                                        value = String(value).trim();
                                        if (value && value !== '' && value !== 'null' && value !== 'undefined') {
                                            if (!fieldMap[name] || value.length > fieldMap[name].length) {
                                                fieldMap[name] = value;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.log('getAnnotations() extraction failed:', e.message);
                }

                // Method 3: Try accessing AcroForm dictionary directly via PDF.js internals
                try {
                    // Access PDF catalog and AcroForm
                    const pdfDocument = pdf;
                    
                    // Try to get the PDF's catalog (root dictionary)
                    if (pdfDocument._pdfInfo) {
                        // Log structure for debugging
                        console.log('PDF info structure keys:', Object.keys(pdfDocument._pdfInfo));
                    }
                    
                    // Try accessing through PDF.js internal structures
                    // Note: This may vary by PDF.js version
                    if (pdfDocument.catalog && pdfDocument.catalog.acroForm) {
                        const acroForm = pdfDocument.catalog.acroForm;
                        console.log('Found AcroForm in catalog:', acroForm);
                    }
                    
                    // Alternative: Try to access via transport
                    if (pdfDocument.transport && pdfDocument.transport.pdfInfo) {
                        const pdfInfo = pdfDocument.transport.pdfInfo;
                        if (pdfInfo.AcroForm) {
                            console.log('Found AcroForm in transport.pdfInfo');
                        }
                    }
                } catch (e) {
                    console.log('AcroForm direct access failed:', e.message);
                }

                // DEBUG: Log field extraction results
                console.log('=== FORM FIELD EXTRACTION DEBUG ===');
                const fieldCount = Object.keys(fieldMap).length;
                console.log('Number of fields found:', fieldCount);
                const fieldKeys = Object.keys(fieldMap);
                if (fieldKeys.length > 0) {
                    console.log('Sample field keys (first 20):', fieldKeys.slice(0, 20));
                    console.log('Sample field values:', Object.fromEntries(
                        fieldKeys.slice(0, 10).map(key => [key, fieldMap[key]])
                    ));
                }

                // Return both text and fieldMap
                return { text: fullText, fieldMap: fieldMap };
            } catch (error) {
                console.error('Error extracting PDF text:', error);
                throw new Error('Failed to extract text from PDF: ' + error.message);
            }
        }

        // Helper function to find a field key using fuzzy matching
        function findKey(fieldMap, possibleKeys) {
            if (!fieldMap || typeof fieldMap !== 'object' || Object.keys(fieldMap).length === 0) {
                return null;
            }
            
            // Handle array of possible keys
            if (!Array.isArray(possibleKeys)) {
                possibleKeys = [possibleKeys];
            }
            
            // First try exact match (case-insensitive)
            const fieldKeys = Object.keys(fieldMap);
            for (const key of possibleKeys) {
                const exactMatch = fieldKeys.find(fk => fk.toLowerCase() === key.toLowerCase());
                if (exactMatch) return exactMatch;
            }
            
            // Then try partial match (contains)
            for (const key of possibleKeys) {
                const partialMatch = fieldKeys.find(fk => 
                    fk.toLowerCase().includes(key.toLowerCase()) || 
                    key.toLowerCase().includes(fk.toLowerCase())
                );
                if (partialMatch) return partialMatch;
            }
            
            // Finally try fuzzy match (word boundaries)
            for (const key of possibleKeys) {
                const keyWords = key.toLowerCase().split(/\s+/);
                const fuzzyMatch = fieldKeys.find(fk => {
                    const fkLower = fk.toLowerCase();
                    return keyWords.every(word => fkLower.includes(word));
                });
                if (fuzzyMatch) return fuzzyMatch;
            }
            
            return null;
        }

        function parseFromFields(fieldMap, textFallback) {
            const profile = {
                name: '',
                className: '',
                level: 0,
                ac: undefined,
                hpMax: undefined,
                speed: undefined,
                initiativeBonus: undefined,
                spellAttackBonus: undefined,
                spellSaveDC: undefined,
                spellSlots: {},
                cantrips: [],
                spells: [],
                rawText: textFallback || '',
                rawFields: fieldMap || {}
            };

            // Helper to parse numeric value from field
            const parseNumeric = (value) => {
                if (!value) return undefined;
                const str = String(value).trim();
                // Extract first number (handles "+2", "16", "30 ft", etc.)
                const match = str.match(/([+-]?\d+)/);
                return match ? parseInt(match[1], 10) : undefined;
            };

            // Use fieldMap as source of truth - only parse if fieldMap exists and has entries
            const hasFieldMap = fieldMap && typeof fieldMap === 'object' && Object.keys(fieldMap).length > 0;

            if (hasFieldMap) {
                // Parse Name from fieldMap
                if (fieldMap.CharacterName) {
                    profile.name = String(fieldMap.CharacterName).trim();
                }

                // Parse Class + Level from fieldMap
                const classLevelKey = findKey(fieldMap, ['CLASS  LEVEL', 'Class Level', 'ClassLevel', 'CLASSLEVEL']);
                if (classLevelKey && fieldMap[classLevelKey]) {
                    const classLevelStr = String(fieldMap[classLevelKey]).trim();
                    // Match "Cleric 2" or "Cleric2" pattern
                    const classLevelMatch = classLevelStr.match(/\b(barbarian|bard|cleric|druid|fighter|monk|paladin|ranger|rogue|sorcerer|warlock|wizard)\s*(\d+)\b/i);
                    if (classLevelMatch) {
                        profile.className = classLevelMatch[1].charAt(0).toUpperCase() + classLevelMatch[1].slice(1).toLowerCase();
                        profile.level = parseInt(classLevelMatch[2], 10);
                    }
                }

                // Parse AC (Armor Class) from fieldMap
                const acKey = findKey(fieldMap, ['ARMOR CLASS', 'AC', 'ArmorClass', 'Armor Class']);
                if (acKey && fieldMap[acKey]) {
                    profile.ac = parseNumeric(fieldMap[acKey]);
                }

                // Parse HP Max from fieldMap
                const hpMaxKey = findKey(fieldMap, ['Max HP', 'HPMax', 'HP Max', 'MAX HP', 'Hit Points']);
                if (hpMaxKey && fieldMap[hpMaxKey]) {
                    const hpValue = String(fieldMap[hpMaxKey]).trim();
                    // Handle "15/15" format - take the second number
                    const hpMatch = hpValue.match(/(\d+)\s*\/\s*(\d+)/);
                    if (hpMatch) {
                        profile.hpMax = parseInt(hpMatch[2], 10);
                    } else {
                        profile.hpMax = parseNumeric(hpValue);
                    }
                }

                // Parse Speed from fieldMap
                const speedKey = findKey(fieldMap, ['SPEED', 'Speed', 'WALKING', 'Walking']);
                if (speedKey && fieldMap[speedKey]) {
                    profile.speed = parseNumeric(fieldMap[speedKey]);
                }

                // Parse Initiative Bonus from fieldMap
                const initiativeKey = findKey(fieldMap, ['INITIATIVE', 'Initiative', 'InitiativeBonus']);
                if (initiativeKey && fieldMap[initiativeKey]) {
                    profile.initiativeBonus = parseNumeric(fieldMap[initiativeKey]);
                }

                // Parse Spell Save DC from exact field (no fuzzy search)
                if (fieldMap.spellSaveDC0) {
                    profile.spellSaveDC = parseInt(fieldMap.spellSaveDC0, 10);
                }

                // Parse Spell Attack Bonus from exact field (no fuzzy search)
                if (fieldMap.spellAtkBonus0) {
                    const bonusStr = String(fieldMap.spellAtkBonus0).trim();
                    profile.spellAttackBonus = parseNumeric(bonusStr);
                }

                // Parse Spellcasting Ability (optional, for reference)
                if (fieldMap.spellCastingAbility0) {
                    profile.spellcastingAbility = String(fieldMap.spellCastingAbility0).trim();
                }

                // Parse Spell Slots from exact field spellSlotHeader1
                profile.spellSlots = {};
                if (fieldMap.spellSlotHeader1) {
                    const slotValue = String(fieldMap.spellSlotHeader1).trim();
                    const m = slotValue.match(/(\d+)\s+Slots/i);
                    if (m) {
                        profile.spellSlots[1] = parseInt(m[1], 10);
                    }
                }
                // Do NOT populate levels 2-9

                // Build spell rows from spellName0 through spellName21 (all spell names in order)
                const rows = [];
                for (let i = 0; i <= 21; i++) {
                    const v = fieldMap[`spellName${i}`];
                    if (typeof v === 'string' && v.trim()) {
                        rows.push(v.trim());
                    }
                }

                // Find header positions in the array (if headers are in spellName fields)
                const cantripHeaderIndex = rows.findIndex(row => /^===.*CANTRIPS.*===/i.test(row));
                const lvl1HeaderIndex = rows.findIndex(row => /^===.*1ST.*LEVEL.*===/i.test(row));

                // Split cantrips and spells
                let cantrips = [];
                let spellsLvl1 = [];

                if (cantripHeaderIndex >= 0 && lvl1HeaderIndex >= 0) {
                    // Headers found in array - split between them
                    cantrips = rows.slice(cantripHeaderIndex + 1, lvl1HeaderIndex);
                    spellsLvl1 = rows.slice(lvl1HeaderIndex + 1);
                } else {
                    // Headers not in array - use fixed split (first 6 are cantrips for this PDF)
                    // spellHeader0 and spellHeader1 are in separate fields, so we use fixed split
                    cantrips = rows.slice(0, 6); // Guidance..Spare the Dying
                    spellsLvl1 = rows.slice(6);  // Healing Word..Bless
                }

                // Filter out header-like values starting with "==="
                const filterHeaders = (arr) => {
                    return arr.filter(item => !item.startsWith('==='));
                };

                // Deduplicate while preserving order
                const deduplicate = (arr) => {
                    const seen = new Set();
                    const result = [];
                    for (const item of arr) {
                        if (!seen.has(item)) {
                            seen.add(item);
                            result.push(item);
                        }
                    }
                    return result;
                };

                // Process and assign
                cantrips = filterHeaders(cantrips);
                spellsLvl1 = filterHeaders(spellsLvl1);
                
                profile.cantrips = deduplicate(cantrips);
                profile.spells = deduplicate(spellsLvl1);
            }

            // FALLBACK: Use regex on textFallback ONLY if fieldMap is missing or empty
            if (!hasFieldMap && textFallback) {
                // Fallback for Name (only if not found in fieldMap)
                if (!profile.name) {
                    const lines = textFallback.split('\n').map(line => line.trim()).filter(line => line);
                    for (let i = 0; i < Math.min(10, lines.length); i++) {
                        const line = lines[i];
                        if (!line.toLowerCase().includes('character') && 
                            !line.toLowerCase().includes('sheet') &&
                            !line.toLowerCase().includes('d&d') &&
                            line.length > 2 && line.length < 50) {
                            profile.name = line;
                            break;
                        }
                    }
                }

                // Fallback for Class + Level (only if not found in fieldMap)
                if (!profile.className || !profile.level) {
                    const classLevelMatch = textFallback.match(/\b(barbarian|bard|cleric|druid|fighter|monk|paladin|ranger|rogue|sorcerer|warlock|wizard)\s+(\d+)\b/i);
                    if (classLevelMatch) {
                        profile.className = classLevelMatch[1].charAt(0).toUpperCase() + classLevelMatch[1].slice(1).toLowerCase();
                        profile.level = parseInt(classLevelMatch[2], 10);
                    }
                }

                // Fallback for AC (only if not found in fieldMap)
                if (profile.ac === undefined) {
                    const acMatch = textFallback.match(/\b(?:ac|armor\s+class)[:\s]+(\d+)\b/i);
                    if (acMatch) {
                        profile.ac = parseInt(acMatch[1], 10);
                    }
                }

                // Fallback for HP Max (only if not found in fieldMap)
                if (profile.hpMax === undefined) {
                    const hpMatch = textFallback.match(/\b(?:hit\s+points|hp)[:\s]+(?:(\d+)\s*\/\s*)?(\d+)\b/i);
                    if (hpMatch) {
                        profile.hpMax = parseInt(hpMatch[2] || hpMatch[1], 10);
                    }
                }

                // Fallback for Speed (only if not found in fieldMap)
                if (profile.speed === undefined) {
                    const speedMatch = textFallback.match(/\bspeed[:\s]+(\d+)\s*(?:ft|feet)?\b/i);
                    if (speedMatch) {
                        profile.speed = parseInt(speedMatch[1], 10);
                    }
                }

                // Fallback for Initiative (only if not found in fieldMap)
                if (profile.initiativeBonus === undefined) {
                    const initiativeMatch = textFallback.match(/\binitiative[:\s]*([+-]?\d+)\b/i);
                    if (initiativeMatch) {
                        profile.initiativeBonus = parseInt(initiativeMatch[1], 10);
                    }
                }

                // No fallback for spell-related fields - we use exact field names only
            }

            return profile;
        }

        function applyCharacterProfileToSettings(profile) {
            // Apply settings based on profile
            prefs.bonusActionEnabled = true;
            prefs.canHealingWord = profile.spells && profile.spells.some(s => s.toLowerCase().includes('healing word'));
            prefs.trackReaction = true;
            prefs.trackInteraction = true;
            prefs.canOffhandAttack = false; // Default for cleric + shield style
            prefs.spellcasterMode = profile.className && profile.className.toLowerCase().includes('cleric');
            prefs.confirmSpends = !!profile.spellSlots && Object.keys(profile.spellSlots).length > 0;
            prefs.decisionHelperEnabled = true;
            prefs.autoResetOnStartTurn = true;

            // Set class if it matches
            const classSelect = document.getElementById('class-select');
            if (classSelect && profile.className) {
                const classKey = profile.className.toLowerCase();
                const validClasses = ['barbarian', 'bard', 'cleric', 'fighter', 'monk', 'paladin', 'ranger', 'rogue', 'sorcerer', 'warlock', 'wizard'];
                if (validClasses.includes(classKey)) {
                    prefs.classKey = classKey;
                    classSelect.value = classKey;
                    applyClassPresets(classKey);
                }
            }

            // Update UI checkboxes
            const toggleBonusAction = document.getElementById('toggle-bonus-action-enabled');
            const toggleHealing = document.getElementById('toggle-healing-word');
            const toggleOffhand = document.getElementById('toggle-offhand-attack');
            const toggleTrackReaction = document.getElementById('toggle-track-reaction');
            const toggleTrackInteraction = document.getElementById('toggle-track-interaction');
            const toggleSpellcaster = document.getElementById('toggle-spellcaster-mode');
            const toggleConfirmSpends = document.getElementById('toggle-confirm-spends');
            const toggleDecisionHelper = document.getElementById('toggle-decision-helper');
            const toggleAutoReset = document.getElementById('toggle-auto-reset');

            if (toggleBonusAction) toggleBonusAction.checked = prefs.bonusActionEnabled;
            if (toggleHealing) toggleHealing.checked = prefs.canHealingWord;
            if (toggleOffhand) toggleOffhand.checked = prefs.canOffhandAttack;
            if (toggleTrackReaction) toggleTrackReaction.checked = prefs.trackReaction;
            if (toggleTrackInteraction) toggleTrackInteraction.checked = prefs.trackInteraction;
            if (toggleSpellcaster) toggleSpellcaster.checked = prefs.spellcasterMode;
            if (toggleConfirmSpends) toggleConfirmSpends.checked = prefs.confirmSpends;
            if (toggleDecisionHelper) toggleDecisionHelper.checked = prefs.decisionHelperEnabled;
            if (toggleAutoReset) toggleAutoReset.checked = prefs.autoResetOnStartTurn;

            // Save preferences
            savePrefs();

            // Add ID to profile and save
            if (!profile.id) {
                profile.id = generateCharacterId();
            }
            const characterId = saveCharacterProfile(profile, profile.id);
            console.log('Character saved with ID:', characterId);

            // Update UI
            updateUI();
        }

        function showImportConfirmDialog(profile, extractedText) {
            const dialogBody = document.getElementById('import-confirm-dialog-body');
            if (!dialogBody) return;

            // Use stored debug text if available
            if (!extractedText && profile._debugExtractedText) {
                extractedText = profile._debugExtractedText;
            }

            let html = '';

            const addItem = (label, value, emptyText = 'Not found') => {
                html += '<div class="profile-item">';
                html += `<div class="profile-label">${label}</div>`;
                if (value !== undefined && value !== null && value !== '' && 
                    !(Array.isArray(value) && value.length === 0) &&
                    !(typeof value === 'object' && Object.keys(value).length === 0)) {
                    if (Array.isArray(value)) {
                        html += `<div class="profile-value">${value.join(', ') || emptyText}</div>`;
                    } else if (typeof value === 'object') {
                        const entries = Object.entries(value).map(([k, v]) => `Level ${k}: ${v}`).join(', ');
                        html += `<div class="profile-value">${entries || emptyText}</div>`;
                    } else {
                        html += `<div class="profile-value">${value}</div>`;
                    }
                } else {
                    html += `<div class="profile-value empty">${emptyText}</div>`;
                }
                html += '</div>';
            };

            addItem('Name', profile.name);
            addItem('Class & Level', profile.className && profile.level ? `${profile.className} ${profile.level}` : null);
            addItem('AC', profile.ac);
            addItem('Max HP', profile.hpMax);
            addItem('Speed', profile.speed ? `${profile.speed} ft` : null);
            addItem('Initiative Bonus', profile.initiativeBonus !== undefined ? (profile.initiativeBonus >= 0 ? '+' : '') + profile.initiativeBonus : null);
            addItem('Spell Attack Bonus', profile.spellAttackBonus !== undefined ? (profile.spellAttackBonus >= 0 ? '+' : '') + profile.spellAttackBonus : null);
            addItem('Spell Save DC', profile.spellSaveDC);
            addItem('Spell Slots', profile.spellSlots);
            addItem('Cantrips', profile.cantrips);
            addItem('Spells', profile.spells);

            // DEBUG SECTION
            if (extractedText) {
                html += '<div class="profile-item" style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 2px solid var(--border);">';
                html += '<div class="profile-label">üîç Debug Info</div>';
                html += `<div class="profile-value" style="margin-bottom: 0.5rem;">Extracted text length: ${extractedText.length}</div>`;
                html += '<details style="margin-top: 0.5rem;">';
                html += '<summary style="cursor: pointer; color: var(--text-light); font-size: 0.9rem;">Show first 1000 characters</summary>';
                html += '<pre style="margin-top: 0.5rem; padding: 0.75rem; background: var(--background); border: 1px solid var(--border); border-radius: 4px; overflow-x: auto; font-size: 0.85rem; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;">';
                html += escapeHtml(extractedText.substring(0, 1000));
                html += '</pre>';
                html += '</details>';
                html += '</div>';
            }

            dialogBody.innerHTML = html;
            document.getElementById('import-confirm-dialog').classList.add('active');
        }

        // Helper function to escape HTML for safe display
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function closeImportConfirmDialog() {
            document.getElementById('import-confirm-dialog').classList.remove('active');
            pendingCharacterProfile = null;
        }

        function confirmCharacterImport() {
            if (pendingCharacterProfile) {
                applyCharacterProfileToSettings(pendingCharacterProfile);
                closeImportConfirmDialog();
                populateCharacterLibrary(); // Update library dropdown
                showToast('Character imported successfully!');
                showScreen('screen-home');
            }
        }

        async function handlePdfImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.includes('pdf') && !file.name.toLowerCase().endsWith('.pdf')) {
                showToast('Please select a PDF file.');
                event.target.value = ''; // Reset file input
                return;
            }

            try {
                showToast('Parsing PDF...');
                
                // Extract text and fieldMap from PDF
                const { text, fieldMap } = await extractPdfData(file);
                
                // DEBUG: Log extracted text info
                console.log('=== PDF EXTRACTION DEBUG ===');
                console.log('Extracted text length:', text.length);
                const fieldCount = Object.keys(fieldMap || {}).length;
                console.log('Number of fields found:', fieldCount);
                console.log('First 1000 characters of text:', text.substring(0, 1000));
                console.log('Sample fields:', Object.fromEntries(
                    Object.entries(fieldMap || {}).slice(0, 10)
                ));
                window.__lastPdfText = text; // Store globally for inspection
                window.__lastPdfFields = fieldMap; // Store fieldMap globally for inspection
                
                // DEBUG: Dump spellName values (spellName0..21)
                const spellRows = [];
                for (let i = 0; i <= 21; i++) {
                    const key = `spellName${i}`;
                    const value = fieldMap[key];
                    spellRows.push([key, value]);
                    console.log(`  ${key}:`, value || '(empty)');
                }
                console.log('SPELL ROWS (spellName0..21) - Full dump above');
                
                // DEBUG: Dump spell/DC/attack related fields
                const spellMetaKeys = Object.keys(fieldMap || {}).filter(k => /spell|save dc|attack|ability save|dc/i.test(k));
                console.log('SPELL META KEYS (count):', spellMetaKeys.length);
                spellMetaKeys.forEach(k => {
                    console.log(`  ${k}:`, fieldMap[k]);
                });
                
                // DEBUG: Fix slot keys log to print real contents
                const slotKeys = Object.keys(fieldMap || {}).filter(k => /slot/i.test(k));
                console.log('SLOT PAIRS (count):', slotKeys.length);
                slotKeys.forEach(k => {
                    console.log(`  ${k}:`, fieldMap[k]);
                });
                
                // Safety check: Too little text and no fields
                if (text.length < 200 && (!fieldMap || fieldCount === 0)) {
                    showToast('No readable text found in this PDF (may be flattened image or blocked worker).');
                    console.warn('PDF extraction returned very little text:', text.length, 'characters and', fieldCount, 'fields');
                    event.target.value = '';
                    return;
                }
                
                // Parse into character profile using fieldMap as source of truth, text as fallback
                const profile = parseFromFields(fieldMap || {}, text);
                
                // Safety check: Text/fields found but parsing failed
                const hasCoreFields = profile.name || profile.className || profile.ac !== undefined || 
                                     profile.hpMax !== undefined || profile.speed !== undefined;
                if (!hasCoreFields) {
                    showToast('Text found, but format wasn\'t recognized. Likely text-order issue. Check debug output.');
                    console.warn('Parsing found no core fields. Profile:', profile);
                }
                
                // Store for confirmation (include raw text and fieldMap for debug)
                pendingCharacterProfile = profile;
                pendingCharacterProfile._debugExtractedText = text; // Store for debug display
                pendingCharacterProfile._debugFields = fieldMap; // Store fieldMap for debug display
                
                // Show confirmation dialog
                showImportConfirmDialog(profile, text);
                
            } catch (error) {
                console.error('PDF import error:', error);
                showToast('Failed to import PDF: ' + error.message);
            } finally {
                // Reset file input
                event.target.value = '';
            }
        }

        function applyClassPresets(classKey) {
            const toggleBonusAction = document.getElementById('toggle-bonus-action-enabled');
            const toggleHealing = document.getElementById('toggle-healing-word');
            const toggleOffhand = document.getElementById('toggle-offhand-attack');
            const helperPresetSelect = document.getElementById('helper-preset-select');

            // Auto-sync helper preset with class selection
            // Only sync if the class has a helper preset available
            const classesWithPresets = ['cleric', 'barbarian', 'rogue', 'wizard'];
            if (classesWithPresets.includes(classKey)) {
                prefs.helperPreset = classKey;
                if (helperPresetSelect) helperPresetSelect.value = classKey;
            } else if (classKey === '' || classKey === 'other') {
                // Clear preset if no class or "other" selected
                prefs.helperPreset = 'none';
                if (helperPresetSelect) helperPresetSelect.value = 'none';
            }

            switch (classKey) {
                case 'cleric':
                    // Cleric: Healing Word ON, Bonus Action enabled
                    prefs.canHealingWord = true;
                    prefs.bonusActionEnabled = true;
                    if (toggleHealing) toggleHealing.checked = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'barbarian':
                    // Barbarian: Bonus Action enabled (Rage)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'rogue':
                    // Rogue: Bonus Action enabled (Cunning Action)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'monk':
                    // Monk: Bonus Action enabled (Martial Arts, Flurry, etc.)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'fighter':
                    // Fighter: Bonus Action enabled (Second Wind)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'ranger':
                    // Ranger: Bonus Action enabled (various features)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'paladin':
                    // Paladin: Bonus Action enabled (various features)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'bard':
                    // Bard: Bonus Action enabled (Bardic Inspiration)
                    prefs.bonusActionEnabled = true;
                    if (toggleBonusAction) toggleBonusAction.checked = true;
                    break;
                case 'sorcerer':
                case 'warlock':
                case 'wizard':
                    // Spellcasters: Spellcaster mode enabled
                    prefs.spellcasterMode = true;
                    const toggleSpellcaster = document.getElementById('toggle-spellcaster-mode');
                    if (toggleSpellcaster) toggleSpellcaster.checked = true;
                    break;
                default:
                    // Other classes: no auto-presets, user can configure manually
                    break;
            }
            savePrefs();
        }

        // Decision Helper Functions
        const helperPrompts = [
            'Need defense? Consider Dodge.',
            'Enemy trying to flee? Consider Ready or Grapple.',
            'Need to reposition? Disengage first.',
            'Need advantage for an ally? Help.'
        ];

        let currentPromptIndex = 0;

        function getHelperPresetChips(preset) {
            const chips = {
                cleric: [
                    { if: 'Ally down?', then: 'Healing Word' },
                    { if: 'Need defense?', then: 'Dodge / Shield of Faith' },
                    { if: 'Enemies grouped?', then: 'AoE spell' }
                ],
                barbarian: [
                    { if: 'Low HP?', then: 'Rage' },
                    { if: 'Need to close?', then: 'Dash' },
                    { if: 'Enemy near?', then: 'Reckless Attack' }
                ],
                rogue: [
                    { if: 'Need advantage?', then: 'Hide' },
                    { if: 'Need to escape?', then: 'Cunning Action: Disengage' },
                    { if: 'Enemy isolated?', then: 'Sneak Attack' }
                ],
                wizard: [
                    { if: 'Allies in danger?', then: 'Shield / Counterspell' },
                    { if: 'Enemies grouped?', then: 'AoE spell' },
                    { if: 'Need info?', then: 'Detect Magic' }
                ]
            };
            return chips[preset] || [];
        }

        function rotateHelperPrompt() {
            if (!prefs.decisionHelperEnabled) return;
            currentPromptIndex = (currentPromptIndex + 1) % helperPrompts.length;
            updateHelperPrompt();
        }

        function updateHelperPrompt() {
            const promptEl = document.getElementById('decision-helper-prompt');
            if (promptEl) {
                promptEl.textContent = helperPrompts[currentPromptIndex];
            }
        }

        function handleHelperChipClick(chipText) {
            showToast('Suggestion: ' + chipText);
        }

        function updateDecisionHelper() {
            const helperBox = document.getElementById('decision-helper-box');
            const chipsContainer = document.getElementById('decision-helper-chips');
            
            if (!helperBox || !chipsContainer) return;

            if (prefs.decisionHelperEnabled) {
                helperBox.style.display = 'block';
                // Rotate prompt each time ACTION screen is opened (show current, then advance for next time)
                updateHelperPrompt();
                currentPromptIndex = (currentPromptIndex + 1) % helperPrompts.length;
                
                // Update chips based on preset
                chipsContainer.innerHTML = '';
                if (prefs.helperPreset && prefs.helperPreset !== 'none') {
                    const chips = getHelperPresetChips(prefs.helperPreset);
                    chips.forEach(chip => {
                        const chipEl = document.createElement('button');
                        chipEl.className = 'decision-helper-chip';
                        chipEl.textContent = chip.if + ' ‚Üí ' + chip.then;
                        chipEl.onclick = () => handleHelperChipClick(chip.then);
                        chipsContainer.appendChild(chipEl);
                    });
                    chipsContainer.style.display = 'flex';
                } else {
                    chipsContainer.style.display = 'none';
                }
            } else {
                helperBox.style.display = 'none';
            }
        }

        function wirePrefsUI() {
            const classSelect = document.getElementById('class-select');
            const toggleBonusAction = document.getElementById('toggle-bonus-action-enabled');
            const toggleHealing = document.getElementById('toggle-healing-word');
            const toggleOffhand = document.getElementById('toggle-offhand-attack');
            const toggleTrackReaction = document.getElementById('toggle-track-reaction');
            const toggleTrackInteraction = document.getElementById('toggle-track-interaction');
            const toggleExtraAttack = document.getElementById('toggle-extra-attack');
            const toggleSpellcaster = document.getElementById('toggle-spellcaster-mode');
            const toggleConfirmSpends = document.getElementById('toggle-confirm-spends');
            const toggleBigButton = document.getElementById('toggle-big-button-mode');
            const toggleAutoReset = document.getElementById('toggle-auto-reset');
            const toggleDecisionHelper = document.getElementById('toggle-decision-helper');
            const helperPresetSelect = document.getElementById('helper-preset-select');

            if (classSelect) {
                classSelect.addEventListener('change', () => {
                    prefs.classKey = classSelect.value;
                    applyClassPresets(classSelect.value);
                    updateUI();
                });
            }

            if (toggleBonusAction) {
                toggleBonusAction.addEventListener('change', () => {
                    prefs.bonusActionEnabled = !!toggleBonusAction.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleHealing) {
                toggleHealing.addEventListener('change', () => {
                    prefs.canHealingWord = !!toggleHealing.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleOffhand) {
                toggleOffhand.addEventListener('change', () => {
                    prefs.canOffhandAttack = !!toggleOffhand.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleTrackReaction) {
                toggleTrackReaction.addEventListener('change', () => {
                    prefs.trackReaction = !!toggleTrackReaction.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleTrackInteraction) {
                toggleTrackInteraction.addEventListener('change', () => {
                    prefs.trackInteraction = !!toggleTrackInteraction.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleExtraAttack) {
                toggleExtraAttack.addEventListener('change', () => {
                    prefs.extraAttackReminder = !!toggleExtraAttack.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleSpellcaster) {
                toggleSpellcaster.addEventListener('change', () => {
                    prefs.spellcasterMode = !!toggleSpellcaster.checked;
                    savePrefs();
                    updateUI();
                });
            }

            if (toggleConfirmSpends) {
                toggleConfirmSpends.addEventListener('change', () => {
                    prefs.confirmSpends = !!toggleConfirmSpends.checked;
                    savePrefs();
                });
            }

            if (toggleBigButton) {
                toggleBigButton.addEventListener('change', () => {
                    prefs.bigButtonMode = !!toggleBigButton.checked;
                    savePrefs();
                    if (prefs.bigButtonMode) {
                        document.body.classList.add('big-button-mode');
                    } else {
                        document.body.classList.remove('big-button-mode');
                    }
                });
            }

            if (toggleAutoReset) {
                toggleAutoReset.addEventListener('change', () => {
                    prefs.autoResetOnStartTurn = !!toggleAutoReset.checked;
                    savePrefs();
                });
            }

            if (toggleDecisionHelper) {
                toggleDecisionHelper.addEventListener('change', () => {
                    prefs.decisionHelperEnabled = !!toggleDecisionHelper.checked;
                    savePrefs();
                    updateDecisionHelper();
                });
            }

            if (helperPresetSelect) {
                helperPresetSelect.addEventListener('change', () => {
                    prefs.helperPreset = helperPresetSelect.value || 'none';
                    savePrefs();
                    updateDecisionHelper();
                });
            }
        }

        // Theme Management - Listen to hub's theme preference
        (function() {
            const THEME_KEY = 'dnd-hub-theme';
            const DARK_MODE_CLASS = 'dark-mode';

            function applyTheme(theme) {
                const html = document.documentElement;
                if (theme === 'dark') {
                    html.classList.add(DARK_MODE_CLASS);
                } else {
                    html.classList.remove(DARK_MODE_CLASS);
                }
            }

            function checkTheme() {
                const saved = localStorage.getItem(THEME_KEY);
                if (saved) {
                    applyTheme(saved);
                } else {
                    // Check system preference if hub hasn't set one
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        applyTheme('dark');
                    } else {
                        applyTheme('light');
                    }
                }
            }

            function initTheme() {
                checkTheme();
                
                // Listen for storage events (if opened in different tab)
                window.addEventListener('storage', function(e) {
                    if (e.key === THEME_KEY) {
                        applyTheme(e.newValue || 'light');
                    }
                });
                
                // Fallback polling at slower rate (1000ms) for same-tab changes
                setInterval(checkTheme, 1000);
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initTheme);
            } else {
                initTheme();
            }
        })();

        // Toggle reaction detail expansion
        function toggleReactionDetail(element) {
            element.classList.toggle('expanded');
        }

        // Toggle collapsible section
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.toggle('expanded');
            }
        }

        // Auto-detect mobile and enable big buttons by default
        function detectMobile() {
            // Check if user has explicitly set bigButtonMode preference
            const saved = localStorage.getItem(PREFS_KEY);
            if (saved) {
                const savedPrefs = JSON.parse(saved);
                // If user has explicitly set it, don't override
                if (savedPrefs.bigButtonMode !== undefined) {
                    return;
                }
            }
            
            // Detect mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                            (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) ||
                            ('ontouchstart' in window);
            
            if (isMobile && prefs.bigButtonMode === false) {
                prefs.bigButtonMode = true;
                savePrefs();
                // Apply immediately
                if (prefs.bigButtonMode) {
                    document.body.classList.add('big-button-mode');
                }
            }
        }

        // Show help section on first visit
        function initHelpSection() {
            const helpSection = document.getElementById('help-section');
            if (!helpSection) return;
            
            const hasSeenHelp = localStorage.getItem('hasSeenHelp');
            if (!hasSeenHelp) {
                // First visit - show expanded
                helpSection.classList.add('expanded');
                localStorage.setItem('hasSeenHelp', 'true');
            }
        }

        // Initialize
        loadPrefs();
        detectMobile();
        wirePrefsUI();
        loadState();
        updateUI();
        initHelpSection();
    </script>
</body>
</html>
